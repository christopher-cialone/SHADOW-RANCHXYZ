# BRB: A Solana Adventure - Complete System Rebuild & Progression Fix

**Project Goal:** Perform a definitive, comprehensive rebuild and enhancement of the "BRB: A Solana Adventure" application to permanently resolve all outstanding issues, including lesson progression, layout overlaps, HTML warnings, and enabling core data persistence. This prompt will provide exact code for file replacements.

**Current State Confirmed:**
* **Lesson Progression Blocked:** `client/src/data/lessons.ts` is incomplete; Lesson 2 only has Step 1 defined.
* **HTML Warning:** `<a> cannot appear as a descendant of <a>` in `Header.tsx`.
* **Layout Overlaps:** Header in `LessonLayout.tsx`, missing bottom navigation, floating footer.
* **Persistence (Firestore):** Not implemented; `MemStorage` is still active, and frontend hooks use `useState`/`localStorage`.
* **Reward/Hint/PIXI.js Components:** Not implemented in the codebase.
* **Console Output:** Basic, lacks dynamic styling and structured error display.

---

**Instructions for Replit Agent (Comprehensive & Definitive Rebuild):**

**Phase 1: Foundation - File Replacements & Core Setup (ABSOLUTELY CRITICAL)**

* **Objective:** Ensure the core data (lessons, templates) and fundamental Firebase setup are correctly in place. **These steps require deleting existing file content and pasting the new content entirely.**

1.  **Completely REPLACE `client/src/data/lessons.ts` Content:**
    * **File:** `client/src/data/lessons.ts`
    * **Action:** **DELETE ALL EXISTING CONTENT** in this file. Then, **PASTE THE ENTIRE BLOCK BELOW** as its new content. This defines all 3 steps for Lesson 2 and a placeholder for Lesson 3.
    * **Implementation:**
        ```typescript
        // client/src/data/lessons.ts - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        export interface LessonData {
            id: number;
            title: string;
            description: string;
            chapter: number;
            difficulty: 'beginner' | 'intermediate' | 'advanced';
            estimatedTime: number; // in minutes
            isPremium: boolean;
            content: {
                steps: LessonStep[];
            };
            codeTemplate?: string; // Optional: for general lesson, specific templates in steps
        }

        export interface LessonStep {
            id: number;
            title: string;
            challenge: string;
            expectedCodePattern: { rust?: string; python?: string; }; // Regex string
            successMessage: string;
            failureMessage: string;
            initialCodeTemplateKey: string; // Key from code-templates.ts
            visualEffectTrigger?: 'networkPing' | 'sparkle' | 'coinFall' | 'messageBoard' | 'transaction' | 'dataStream' | 'blueprint';
            hintMessage?: string;
        }

        export const lessons: LessonData[] = [
            {
                id: 1, // Lesson 1: Solana Basics & Wallet Setup
                title: "Solana Basics & Wallet Setup",
                description: "Learn the fundamentals of Solana and set up your Web3 wallet",
                chapter: 1,
                difficulty: 'beginner',
                estimatedTime: 30,
                isPremium: false,
                content: {
                    steps: [
                        {
                            id: 1,
                            title: "Ping the Blockchain",
                            challenge: "Write `get_network_status()` to check Devnet health.",
                            expectedCodePattern: { rust: 'get_network_status\\(\\)', python: 'get_network_status\\(\\)' },
                            successMessage: "Network Status: Connected! Ping: {ping}ms | Current Slot: {slot}",
                            initialCodeTemplateKey: 'default',
                            visualEffectTrigger: 'networkPing',
                            hintMessage: "Remember, the network status command is a simple function call. Look for a function that doesn't require any arguments!"
                        },
                    ]
                },
            },
            {
                id: 2, // Lesson 2: Creating Your Ranch Account
                title: "Creating Your Ranch Account",
                description: "Build your first Solana program to manage ranch data",
                chapter: 2,
                difficulty: 'beginner',
                estimatedTime: 45,
                isPremium: false,
                content: {
                    steps: [
                        {
                            id: 1,
                            title: "Define Ranch Owner Field",
                            challenge: "Your ranch needs an owner! In the `Ranch` struct (Rust) or `Ranch` class (Python), add a `pubkey` field named `owner`. This will identify who controls the ranch. Don't forget the comma for Rust!",
                            expectedCodePattern: { rust: 'pub\\s+owner:\\s*Pubkey,', python: 'owner:\\s*Pubkey' },
                            successMessage: "Excellent! The `owner` field has been added. Your ranch now knows who its rightful owner is!",
                            failureMessage: "Not quite. Make sure you've added 'pub owner: Pubkey,' (Rust) or 'owner: Pubkey' (Python) exactly inside the Ranch definition. Check for typos and correct capitalization!",
                            initialCodeTemplateKey: 'ranch_management_initial',
                            visualEffectTrigger: 'blueprint',
                            hintMessage: "Think about Rust structs or Python classes. You need to add a line that declares a public key variable named 'owner' within your 'Ranch' data structure."
                        },
                        {
                            id: 2,
                            title: "Initialize Owner in `initialize_ranch`",
                            challenge: "Now, inside the `initialize_ranch` function, assign the `owner` field of your `ranch` account to the `ctx.accounts.owner.key()` (Rust) or `owner.key()` (Python). Remember `ranch.owner = ctx.accounts.owner.key();` or `ranch.owner = owner.key()`.",
                            expectedCodePattern: { rust: 'ranch\\.owner\\s*=\\s*ctx\\.accounts\\.owner\\.key\\(\\);', python: 'ranch\\.owner\\s*=\\s*owner\\.key\\(\\)' },
                            successMessage: "Owner successfully initialized! Your ranch deed is now registered to you!",
                            failureMessage: "The owner assignment is incorrect. Double-check the syntax for assigning the owner's key to the ranch account. Hint: Look at the `ctx.accounts.owner` context in Rust or `owner` parameter in Python.",
                            initialCodeTemplateKey: 'ranch_management_step1_complete',
                            visualEffectTrigger: 'sparkle',
                            hintMessage: "You need to set the 'owner' field of your 'ranch' variable to the public key of the user who's calling this program. In Rust, you'll use `ctx.accounts.owner.key()`; in Python, `owner.key()`."
                        },
                        {
                            id: 3,
                            title: "Programmatic Ownership: Securing Your Ranch with a Program Derived Address (PDA)",
                            challenge: `Welcome, digital homesteader! In this decentralized frontier, we value true ownership and privacy. Unlike the old world where deeds were on paper in a dusty office, here, your ranch deed can be controlled by pure code! This is the essence of **cypher-punk** – using cryptography and decentralized tech to protect privacy and freedom.
                            Today, we're diving into **Program Derived Addresses (PDAs)**. Imagine your ranch deed isn't owned by a specific wallet with a private key, but by a special, unhackable 'strongbox' that *only your ranch program can open*. This strongbox address is *derived* from your program's ID and some unique 'seeds' (like a secret password) and a 'bump' (a special number to make sure it's valid). This makes your ranch truly **decentralized** and secure, giving control to the smart contract itself, not a person's key.

                            **Your Task:**
                            1.  In the \`InitializeRanch\` struct (Rust) or function definition (Python), locate the \`#[account(...)]\` attribute for your \`ranch\` account.
                            2.  **Add a \`seeds\` argument** to this attribute. For the ranch, the seeds will be the byte literal \`b"ranch"\` and the owner's public key (\`owner.key().as_ref()\` in Rust, \`owner\` in Python).
                            3.  **Add a \`bump\` argument** to this attribute. This is a special nonce that ensures the PDA is valid.`,
                            expectedCodePattern: {
                                rust: 'seeds\\s*=\\s*\\[b"ranch",\\s*owner\\.key\\(\\)\\.as_ref\\(\\)\\]\\s*,\\s*bump',
                                python: 'seeds=\\[\'ranch\',\\s*owner\\]\\s*,\\s*bump'
                            },
                            successMessage: "Fantastic! Your ranch account is now a true Program Derived Address (PDA)! Its deed is safely locked away, controlled by your program, not a private key. You've embraced programmatic ownership!",
                            failureMessage: "Not quite. Double-check your PDA syntax. Did you add `seeds` and `bump` correctly within the `#[account(...)]` attribute (Rust) or `init` arguments (Python)? Remember the exact values for the seeds (`b\"ranch\"` and the owner's key) and that `bump` is also required!",
                            initialCodeTemplateKey: 'ranch_management_step2_complete',
                            visualEffectTrigger: 'dataStream',
                            hintMessage: `Okay, digital prospector! Think of PDAs like a magic lockbox only your program can open. You need to tell Solana:
                            1.  What 'words' (seeds) make this lockbox unique (e.g., the word "ranch" and the owner's special key).
                            2.  A special number (the 'bump') that makes sure the lockbox address is perfect and unhackable.
                            Look at the \`#[account(...)]\` line for the \`ranch\` in Rust, or the \`.init()\` call in Python, and add the \`seeds\` and \`bump\` keywords!`
                        },
                    ]
                },
            },
            {
                id: 3, // Placeholder for Lesson 3
                title: "Introduction to NFTs: Minting Your First Digital Asset",
                description: "Learn how to create and mint Non-Fungible Tokens (NFTs) on Solana.",
                chapter: 3,
                difficulty: 'intermediate',
                estimatedTime: 60,
                isPremium: false,
                content: {
                    steps: [
                        {
                            id: 1,
                            title: "Coming Soon...",
                            challenge: "This lesson is under development. Check back soon for exciting challenges!",
                            expectedCodePattern: {},
                            successMessage: "",
                            failureMessage: "",
                            initialCodeTemplateKey: 'default',
                            hintMessage: "More challenges are on the way!"
                        }
                    ]
                }
            },
            {
                id: 4,
                title: "RanchCoin Token Creation",
                description: "Deploy your own SPL token for in-game economy",
                chapter: 4,
                difficulty: 'intermediate',
                estimatedTime: 50,
                isPremium: true,
                content: {
                    steps: [
                        { id: 1, title: "Coming Soon...", challenge: "This lesson is under development.", expectedCodePattern: {}, successMessage: "", failureMessage: "", initialCodeTemplateKey: 'default' }
                    ]
                }
            },
            {
                id: 5,
                title: "Saloon Dueling System",
                description: "Program interactive duels and betting mechanics",
                chapter: 5,
                difficulty: 'advanced',
                estimatedTime: 75,
                isPremium: true,
                content: {
                    steps: [
                        { id: 1, title: "Coming Soon...", challenge: "This lesson is under development.", expectedCodePattern: {}, successMessage: "", failureMessage: "", initialCodeTemplateKey: 'default' }
                    ]
                }
            },
            {
                id: 6,
                title: "Security & Ranch Defense",
                description: "Implement security measures against shadow beasts",
                chapter: 6,
                difficulty: 'advanced',
                estimatedTime: 90,
                isPremium: true,
                content: {
                    steps: [
                        { id: 1, title: "Coming Soon...", challenge: "This lesson is under development.", expectedCodePattern: {}, successMessage: "", failureMessage: "", initialCodeTemplateKey: 'default' }
                    ]
                }
            },
            {
                id: 7,
                title: "Ether Range Expeditions",
                description: "Master cross-program invocations and external integrations",
                chapter: 7,
                difficulty: 'advanced',
                estimatedTime: 120,
                isPremium: true,
                content: {
                    steps: [
                        { id: 1, title: "Coming Soon...", challenge: "This lesson is under development.", expectedCodePattern: {}, successMessage: "", failureMessage: "", initialCodeTemplateKey: 'default' }
                    ]
                }
            }
        ];
        ```

2.  **Completely REPLACE `client/src/data/code-templates.ts` Content:**
    * **File:** `client/src/data/code-templates.ts`
    * **Action:** **DELETE ALL EXISTING CONTENT** in this file. Then, **PASTE THE ENTIRE BLOCK BELOW** as its new content. This ensures templates for Lesson 2, Step 2 and Step 3 are correctly present and referenced.
    * **Implementation:**
        ```typescript
        // client/src/data/code-templates.ts - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        export const rustTemplates = {
          default: `use anchor_lang::prelude::*;

declare_id!("YourProgramID");

#[program]
pub mod my_program {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        msg!("Program initialized!");
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    pub system_program: Program<'info, System>,
}
`,
          ranch_management_initial: `use anchor_lang::prelude::*;

declare_id!("RanchManager111111111111111111111111111111");

#[program]
pub mod ranch_manager {
    use super::*;

    pub fn initialize_ranch(
        ctx: Context<InitializeRanch>,
        ranch_name: String,
    ) -> Result<()> {
        let ranch = &mut ctx.accounts.ranch;
        // TODO: Assign owner field here in a later step (L2S2)
        ranch.name = ranch_name;
        ranch.level = 1;
        ranch.experience = 0;
        ranch.ranch_coin_balance = 500;
        ranch.building_count = 0;
        ranch.character_count = 0;
        ranch.created_at = Clock::get()?.unix_timestamp;

        msg!("Ranch '{}' initialized for owner {}", ranch.name, ranch.owner);
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(ranch_name: String)]
pub struct InitializeRanch<'info> {
    #[account(
        init,
        payer = owner,
        space = 8 + Ranch::INIT_SPACE,
        // USER ADDS SEEDS AND BUMP HERE IN L2S3
        // seeds = [b"ranch", owner.key().as_ref()],
        // bump
    )]
    pub ranch: Account<'info, Ranch>,

    #[account(mut)]
    pub owner: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Ranch {
    // USER ADDS PUB OWNER: PUBKEY, HERE IN L2S1
    pub ranch_coin_balance: u64, // 8
    pub building_count: u8,     // 1
    pub character_count: u8,    // 1
    pub created_at: i64,        // 8
    pub name: String,           // 4 + 32
    pub level: u8,              // 1
    pub experience: u64,        // 8
}

impl Ranch {
    const INIT_SPACE: usize = 8 + 1 + 1 + 8 + 4 + 32 + 1 + 8; // Adjust space as fields are added
}

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access to ranch")]
    UnauthorizedAccess,
}
`,
          ranch_management_step1_complete: `use anchor_lang::prelude::*;

declare_id!("RanchManager111111111111111111111111111111");

#[program]
pub mod ranch_manager {
    use super::*;

    pub fn initialize_ranch(
        ctx: Context<InitializeRanch>,
        ranch_name: String,
    ) -> Result<()> {
        let ranch = &mut ctx.accounts.ranch;
        ranch.owner = ctx.accounts.owner.key(); // This line is added in L2S2
        ranch.name = ranch_name;
        ranch.level = 1;
        ranch.experience = 0;
        ranch.ranch_coin_balance = 500;
        ranch.building_count = 0;
        ranch.character_count = 0;
        ranch.created_at = Clock::get()?.unix_timestamp;

        msg!("Ranch '{}' initialized for owner {}", ranch.name, ranch.owner);
        Ok(())
    }
}

#[derive(Accounts)]
#[instruction(ranch_name: String)]
pub struct InitializeRanch<'info> {
    #[account(
        init,
        payer = owner,
        space = 8 + 32 + 4 + 32 + 1 + 8 + 8 + 1 + 1 + 8, // Adjusted space for 'owner: Pubkey'
        // USER ADDS SEEDS AND BUMP HERE IN L2S3
        // seeds = [b"ranch", owner.key().as_ref()],
        // bump
    )]
    pub ranch: Account<'info, Ranch>,

    #[account(mut)]
    pub owner: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Ranch {
    pub owner: Pubkey, // This line is added in L2S1
    pub ranch_coin_balance: u64,
    pub building_count: u8,
    pub character_count: u8,
    pub created_at: i64,
    pub name: String,
    pub level: u8,
    pub experience: u64,
}

impl Ranch {
    const INIT_SPACE: usize = 32 + 4 + 32 + 1 + 8 + 8 + 1 + 1 + 8; // Updated for Pubkey (32 bytes)
}

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access to ranch")]
    UnauthorizedAccess,
}
`,
        };

        export const pythonTemplates = {
          default: `import seahorse.prelude.*

declare_id('YourProgramID')

@instruction
def initialize(payer: Signer):
    """Initialize a new program"""
    print(f"Program initialized by {payer.key()}")
`,
          ranch_management_initial: `import seahorse.prelude.*

declare_id('RanchManager111111111111111111111111111111')

class Ranch(Account):
    # USER ADDS OWNER: PUBKEY HERE IN L2S1
    ranch_coin_balance: u64
    building_count: u8
    character_count: u8
    created_at: i64
    name: str
    level: u8
    experience: u64

@instruction
def initialize_ranch(
    ranch: Empty[Ranch],
    owner: Signer,
    ranch_name: str
):
    """Initialize a new ranch"""
    ranch = ranch.init(
        payer=owner,
        space=8 + 32 + 32 + 1 + 8 + 8 + 1 + 1 + 8, // Adjust space
        # USER ADDS SEEDS AND BUMP HERE IN L2S3
        # seeds=['ranch', owner],
        # bump
    )

    # TODO: Assign owner field here in a later step (L2S2)
    ranch.name = ranch_name
    ranch.level = 1
    ranch.experience = 0
    ranch.ranch_coin_balance = 500
    ranch.building_count = 0
    ranch.character_count = 0
    ranch.created_at = Clock.unix_timestamp()

    print(f"Ranch '{ranch_name}' initialized for owner {owner.key()}")
`,
          ranch_management_step1_complete: `import seahorse.prelude.*

declare_id('RanchManager111111111111111111111111111111')

class Ranch(Account):
    owner: Pubkey # This line is added in L2S1
    ranch_coin_balance: u64
    building_count: u8
    character_count: u8
    created_at: i64
    name: str
    level: u8
    experience: u64

@instruction
def initialize_ranch(
    ranch: Empty[Ranch],
    owner: Signer,
    ranch_name: str
):
    """Initialize a new ranch"""
    ranch = ranch.init(
        payer=owner,
        space=8 + 32 + 32 + 1 + 8 + 8 + 1 + 1 + 8, // Adjusted space
        # USER ADDS SEEDS AND BUMP HERE IN L2S3
        # seeds=['ranch', owner],
        # bump
    )

    ranch.owner = owner.key() // This line is added in L2S2
    ranch.name = ranch_name
    ranch.level = 1
    ranch.experience = 0
    ranch.ranch_coin_balance = 500
    ranch.building_count = 0
    ranch.character_count = 0
    ranch.created_at = Clock.unix_timestamp()

    print(f"Ranch '{ranch_name}' initialized for owner {owner.key()}")
`,
        };
        ```

3.  **Completely REPLACE `client/src/firebase-init.ts` Content:**
    * **File:** `client/src/firebase-init.ts`
    * **Action:** **DELETE ALL EXISTING CONTENT** in this file. Then, **PASTE THE ENTIRE BLOCK BELOW** as its new content. This ensures Firebase initialization is correct and exports are accessible.
    * **Implementation:**
        ```typescript
        // client/src/firebase-init.ts - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
        import { getFirestore } from 'firebase/firestore';

        // These global variables are provided by the Replit environment
        // If Replit does not inject these, they will be 'undefined'
        declare const __app_id: string;
        declare const __firebase_config: string;
        declare const __initial_auth_token: string;

        // Parse config. Handle potential errors if variables aren't set (e.g., local dev outside Replit)
        let firebaseConfigParsed = {};
        try {
          if (typeof __firebase_config !== 'undefined' && __firebase_config) {
            firebaseConfigParsed = JSON.parse(__firebase_config);
          } else {
            console.warn("__firebase_config not found. Using default empty config. Firebase features might not work.");
          }
        } catch (e) {
          console.error("Failed to parse __firebase_config:", e);
          firebaseConfigParsed = {};
        }

        export const app = initializeApp(firebaseConfigParsed);
        export const auth = getAuth(app);
        export const db = getFirestore(app);
        export const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        export const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
        ```

4.  **Completely REPLACE `server/storage.ts` Content:**
    * **File:** `server/storage.ts`
    * **Action:** **DELETE ALL EXISTING CONTENT** in this file. Then, **PASTE THE ENTIRE BLOCK BELOW** as its new content. This implements `FirestoreStorage` and replaces `MemStorage`.
    * **Implementation:**
        ```typescript
        // server/storage.ts - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        import {
          // Import all relevant schema types from shared/schema.ts
          users, ranches, lessons, userProgress, characters, buildings, rewardNfts,
          type User, type InsertUser, type Ranch, type InsertRanch, type Lesson,
          type UserProgress, type InsertUserProgress, type Character, type InsertCharacter,
          type Building, type InsertBuilding, type RewardNft, type InsertRewardNft
        } from "@shared/schema";
        import { getFirestore, doc, getDoc, setDoc, addDoc, updateDoc, deleteDoc, collection, query, where, getDocs } from "firebase/firestore";
        import { initializeApp } from "firebase/app"; // Import here for server-side init

        // Global variables provided by Replit (they are injected into the environment)
        // These are accessed directly via their global names.
        declare const __app_id: string;
        declare const __firebase_config: string;

        // Initialize Firebase on the server-side (only if not already done globally via another mechanism)
        let firebaseAppInstance: any;
        let firestoreDbInstance: any;

        try {
          const config = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
          if (Object.keys(config).length > 0) { // Only initialize if config is not empty
            firebaseAppInstance = initializeApp(config, "server-side-app"); // Use a unique app name
            firestoreDbInstance = getFirestore(firebaseAppInstance);
          } else {
            console.warn("Firebase config not found or empty on server. Firestore storage will be mocked or non-functional.");
          }
        } catch (e) {
          console.error("Failed to parse __firebase_config on server:", e);
        }

        // Define base paths for Firestore collections, using the Replit app ID for isolation
        const ARTIFACTS_PATH = `artifacts/${typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'}`;

        // Define the IStorage interface (if it's not already in shared/schema.ts or a dedicated interface file)
        export interface IStorage {
            getUser(id: string): Promise<User | undefined>; // Changed to string ID
            getUserByUsername(username: string): Promise<User | undefined>;
            getUserByWalletAddress(walletAddress: string): Promise<User | undefined>;
            createUser(user: InsertUser): Promise<User>;

            getRanch(id: string): Promise<Ranch | undefined>; // Changed to string ID
            getRanchByUserId(userId: string): Promise<Ranch | undefined>;
            createRanch(ranch: InsertRanch): Promise<Ranch>;
            updateRanch(userId: string, updates: Partial<Omit<Ranch, 'id' | 'ownerId' | 'createdAt'>>): Promise<Ranch>; // Update by userId now

            getAllLessons(): Promise<Lesson[]>;
            getLessonById(id: number): Promise<Lesson | undefined>;
            createLesson(lesson: Omit<Lesson, 'id' | 'createdAt'>): Promise<Lesson>;

            getLessonProgress(id: string): Promise<UserProgress | undefined>; // Changed to string ID
            getLessonProgressByUserId(userId: string): Promise<UserProgress[]>;
            getLessonProgressByUserAndLesson(userId: string, lessonId: number): Promise<UserProgress | undefined>;
            createLessonProgress(progress: InsertUserProgress): Promise<UserProgress>;
            updateLessonProgress(id: string, updates: Partial<Omit<UserProgress, 'id' | 'userId' | 'lessonId' | 'createdAt'>>): Promise<UserProgress>;

            getCharacter(id: string): Promise<Character | undefined>; // Changed to string ID
            getCharactersByUserId(userId: string): Promise<Character[]>;
            createCharacter(character: InsertCharacter): Promise<Character>;
            updateCharacter(id: string, updates: Partial<Omit<Character, 'id' | 'ownerId' | 'createdAt'>>): Promise<Character>;

            getBuilding(id: string): Promise<Building | undefined>; // Changed to string ID
            getBuildingsByRanchId(ranchId: number): Promise<Building[]>; // Still numeric ranchId from schema
            createBuilding(building: InsertBuilding): Promise<Building>;
            updateBuilding(id: string, updates: Partial<Omit<Building, 'id' | 'ranchId' | 'createdAt'>>): Promise<Building>;

            getRewardNftsByUserId(userId: string): Promise<RewardNft[]>;
            createRewardNft(insertReward: InsertRewardNft): Promise<RewardNft>;
        }

        export class FirestoreStorage implements IStorage {
          private db: any;

          constructor() {
            if (!firestoreDbInstance) {
              console.error("Firestore DB instance not available in FirestoreStorage constructor.");
              // Fallback or throw error if Firestore not initialized
              throw new Error("Firestore DB not initialized. Cannot use FirestoreStorage.");
            }
            this.db = firestoreDbInstance;
            this.initializeLessons(); // Ensure default lessons are in Firestore
          }

          private getUserCollectionRef(userId: string, collectionName: string) {
            return collection(this.db, `${ARTIFACTS_PATH}/users/${userId}/${collectionName}`);
          }

          private getPublicCollectionRef(collectionName: string) {
            return collection(this.db, `${ARTIFACTS_PATH}/public/data/${collectionName}`);
          }

          private async initializeLessons() {
            const lessonsRef = this.getPublicCollectionRef('lessons');
            const snapshot = await getDocs(lessonsRef);
            if (snapshot.empty) {
              const defaultLessons: Omit<Lesson, 'createdAt'>[] = [ // Remove 'id' from Omit
                // Copy the ENTIRE 'lessons' array content from client/src/data/lessons.ts here.
                // It's crucial for the server to have this data to initialize Firestore.
                // NOTE: When copying, remove the 'id' property from each lesson object,
                // as Firestore will generate its own. The 'id' in schema is just for Drizzle.
                // The 'id' in LessonStep is for logical step progression.
                // For this server-side initialization, use `doc(lessonsRef, '1')`, `doc(lessonsRef, '2')` etc.
                // to explicitly set document IDs to match lesson.id.

                // Lessons 1
                {
                  // id: 1, // DO NOT include ID here, Firestore will set doc ID
                  title: "Solana Basics & Wallet Setup",
                  description: "Learn the fundamentals of Solana and set up your Web3 wallet",
                  chapter: 1,
                  difficulty: 'beginner',
                  estimatedTime: 30,
                  isPremium: false,
                  content: {
                    steps: [
                      {
                        id: 1,
                        title: "Ping the Blockchain",
                        challenge: "Write `get_network_status()` to check Devnet health.",
                        expectedCodePattern: { rust: 'get_network_status\\(\\)', python: 'get_network_status\\(\\)' },
                        successMessage: "Network Status: Connected! Ping: {ping}ms | Current Slot: {slot}",
                        failureMessage: "Command not recognized. Ensure you typed `get_network_status()` exactly.",
                        initialCodeTemplateKey: 'default',
                        visualEffectTrigger: 'networkPing',
                        hintMessage: "Remember, the network status command is a simple function call. Look for a function that doesn't require any arguments!"
                      },
                    ]
                  },
                },
                // Lessons 2
                {
                  // id: 2, // DO NOT include ID here
                  title: "Creating Your Ranch Account",
                  description: "Build your first Solana program to manage ranch data",
                  chapter: 2,
                  difficulty: 'beginner',
                  estimatedTime: 45,
                  isPremium: false,
                  content: {
                    steps: [
                      {
                        id: 1,
                        title: "Define Ranch Owner Field",
                        challenge: "Your ranch needs an owner! In the `Ranch` struct (Rust) or `Ranch` class (Python), add a `pubkey` field named `owner`. This will identify who controls the ranch. Don't forget the comma for Rust!",
                        expectedCodePattern: { rust: 'pub\\s+owner:\\s*Pubkey,', python: 'owner:\\s*Pubkey' },
                        successMessage: "Excellent! The `owner` field has been added. Your ranch now knows who its rightful owner is!",
                        failureMessage: "Not quite. Make sure you've added 'pub owner: Pubkey,' (Rust) or 'owner: Pubkey' (Python) exactly inside the Ranch definition. Check for typos and correct capitalization!",
                        initialCodeTemplateKey: 'ranch_management_initial',
                        visualEffectTrigger: 'blueprint',
                        hintMessage: "Think about Rust structs or Python classes. You need to add a line that declares a public key variable named 'owner' within your 'Ranch' data structure."
                      },
                      {
                        id: 2,
                        title: "Initialize Owner in `initialize_ranch`",
                        challenge: "Now, inside the `initialize_ranch` function, assign the `owner` field of your `ranch` account to the `ctx.accounts.owner.key()` (Rust) or `owner.key()` (Python). Remember `ranch.owner = ctx.accounts.owner.key();` or `ranch.owner = owner.key()`.",
                        expectedCodePattern: { rust: 'ranch\\.owner\\s*=\\s*ctx\\.accounts\\.owner\\.key\\(\\);', python: 'ranch\\.owner\\s*=\\s*owner\\.key\\(\\)' },
                        successMessage: "Owner successfully initialized! Your ranch deed is now registered to you!",
                        failureMessage: "The owner assignment is incorrect. Double-check the syntax for assigning the owner's key to the ranch account. Hint: Look at the `ctx.accounts.owner` context in Rust or `owner` parameter in Python.",
                        initialCodeTemplateKey: 'ranch_management_step1_complete',
                        visualEffectTrigger: 'sparkle',
                        hintMessage: "You need to set the 'owner' field of your 'ranch' variable to the public key of the user who's calling this program. In Rust, you'll use `ctx.accounts.owner.key()`; in Python, `owner.key()`."
                      },
                      {
                        id: 3,
                        title: "Programmatic Ownership: Securing Your Ranch with a Program Derived Address (PDA)",
                        challenge: `Welcome, digital homesteader! In this decentralized frontier, we value true ownership and privacy. Unlike the old world where deeds were on paper in a dusty office, here, your ranch deed can be controlled by pure code! This is the essence of **cypher-punk** – using cryptography and decentralized tech to protect privacy and freedom.
                        Today, we're diving into **Program Derived Addresses (PDAs)**. Imagine your ranch deed isn't owned by a specific wallet with a private key, but by a special, unhackable 'strongbox' that *only your ranch program can open*. This strongbox address is *derived* from your program's ID and some unique 'seeds' (like a secret password) and a 'bump' (a special number to make sure it's valid). This makes your ranch truly **decentralized** and secure, giving control to the smart contract itself, not a person's key.

                        **Your Task:**
                        1.  In the \`InitializeRanch\` struct (Rust) or function definition (Python), locate the \`#[account(...)]\` attribute for your \`ranch\` account.
                        2.  **Add a \`seeds\` argument** to this attribute. For the ranch, the seeds will be the byte literal \`b"ranch"\` and the owner's public key (\`owner.key().as_ref()\` in Rust, \`owner\` in Python).
                        3.  **Add a \`bump\` argument** to this attribute. This is a special nonce that ensures the PDA is valid.`,
                        expectedCodePattern: {
                            rust: 'seeds\\s*=\\s*\\[b"ranch",\\s*owner\\.key\\(\\)\\.as_ref\\(\\)\\]\\s*,\\s*bump',
                            python: 'seeds=\\[\'ranch\',\\s*owner\\]\\s*,\\s*bump'
                        },
                        successMessage: "Fantastic! Your ranch account is now a true Program Derived Address (PDA)! Its deed is safely locked away, controlled by your program, not a private key. You've embraced programmatic ownership!",
                        failureMessage: "Not quite. Double-check your PDA syntax. Did you add `seeds` and `bump` correctly within the `#[account(...)]` attribute (Rust) or `init` arguments (Python)? Remember the exact values for the seeds (`b\"ranch\"` and the owner's key) and that `bump` is also required!",
                        initialCodeTemplateKey: 'ranch_management_step2_complete',
                        visualEffectTrigger: 'dataStream',
                        hintMessage: `Okay, digital prospector! Think of PDAs like a magic lockbox only your program can open. You need to tell Solana:
                        1.  What 'words' (seeds) make this lockbox unique (e.g., the word "ranch" and the owner's special key).
                        2.  A special number (the 'bump') that makes sure the lockbox address is perfect and unhackable.
                        Look at the \`#[account(...)]\` line for the \`ranch\` in Rust, or the \`.init()\` call in Python, and add the \`seeds\` and \`bump\` keywords!`
                      },
                    ]
                  },
                },
                // Placeholder for Lesson 3
                {
                    // id: 3, // DO NOT include ID here
                    title: "Introduction to NFTs: Minting Your First Digital Asset",
                    description: "Learn how to create and mint Non-Fungible Tokens (NFTs) on Solana.",
                    chapter: 3,
                    difficulty: 'intermediate',
                    estimatedTime: 60,
                    isPremium: false,
                    content: {
                        steps: [
                            {
                                id: 1,
                                title: "Coming Soon...",
                                challenge: "This lesson is under development. Check back soon for exciting challenges!",
                                expectedCodePattern: {},
                                successMessage: "",
                                failureMessage: "",
                                initialCodeTemplateKey: 'default',
                                hintMessage: "More challenges are on the way!"
                            }
                        ]
                    }
                },
                // ... (add other lessons if they were present previously, ensuring they follow this new structure and omit 'id')
              ];

              for (const lessonData of defaultLessons) {
                // Use the lesson's conceptual ID as the Firestore document ID for lessons collection
                await setDoc(doc(lessonsRef, lessonData.id.toString()), lessonData);
              }
            }
          }

          // --- User operations ( Firestore string IDs for doc references, mock numeric for return if needed) ---
          async getUser(id: string): Promise<User | undefined> { // ID is Firestore doc ID
            const docRef = doc(this.getPublicCollectionRef('users'), id);
            const docSnap = await getDoc(docRef);
            if (!docSnap.exists()) return undefined;
            return { ...docSnap.data(), id: docSnap.id } as User;
          }

          async getUserByUsername(username: string): Promise<User | undefined> {
            const q = query(this.getPublicCollectionRef('users'), where('username', '==', username));
            const snapshot = await getDocs(q);
            if (snapshot.empty) return undefined;
            const docData = snapshot.docs[0].data();
            return { ...docData, id: snapshot.docs[0].id } as User;
          }

          async getUserByWalletAddress(walletAddress: string): Promise<User | undefined> {
            const q = query(this.getPublicCollectionRef('users'), where('walletAddress', '==', walletAddress));
            const snapshot = await getDocs(q);
            if (snapshot.empty) return undefined;
            const docData = snapshot.docs[0].data();
            return { ...docData, id: snapshot.docs[0].id } as User;
          }

          async createUser(insertUser: InsertUser): Promise<User> {
            // Use walletAddress as the document ID for users for easy lookup
            const userDocRef = doc(this.getPublicCollectionRef('users'), insertUser.walletAddress);
            await setDoc(userDocRef, { ...insertUser, createdAt: new Date() });
            const newUser = (await getDoc(userDocRef)).data() as User;
            return { ...newUser, id: userDocRef.id };
          }

          // --- Ranch operations ---
          async getRanch(id: string): Promise<Ranch | undefined> { // ID is Firestore doc ID (user's UID)
            const ranchDocRef = doc(this.getUserCollectionRef(id, 'ranch'), 'data'); // Assuming 'id' here is user's UID
            const ranchSnap = await getDoc(ranchDocRef);
            if (!ranchSnap.exists()) return undefined;
            return { ...ranchSnap.data(), id: ranchSnap.id } as Ranch;
          }

          async getRanchByUserId(userId: string): Promise<Ranch | undefined> { // userId is string from auth
            const ranchDocRef = doc(this.getUserCollectionRef(userId, 'ranch'), 'data'); // Assume single ranch doc per user
            const ranchSnap = await getDoc(ranchDocRef);
            if (!ranchSnap.exists()) return undefined;
            return { ...ranchSnap.data(), id: ranchSnap.id } as Ranch;
          }

          async createRanch(insertRanch: InsertRanch): Promise<Ranch> {
            // Firestore needs a string userId. InsertRanch has ownerId: number.
            // This needs to be called with a string userId, or derive it here.
            const ownerIdString = insertRanch.ownerId.toString(); // Assuming ownerId is converted to string for Firestore UID
            const ranchDocRef = doc(this.getUserCollectionRef(ownerIdString, 'ranch'), 'data');
            const newRanchData = { ...insertRanch, level: 1, ranchCoinBalance: 500, buildingCount: 0, characterCount: 0, metadata: null, createdAt: new Date(), updatedAt: new Date() };
            await setDoc(ranchDocRef, newRanchData);
            const newRanch = (await getDoc(ranchDocRef)).data() as Ranch;
            return { ...newRanch, id: ranchDocRef.id };
          }

          async updateRanch(userId: string, updates: Partial<Omit<Ranch, 'id' | 'ownerId' | 'createdAt'>>): Promise<Ranch> { // Update by userId (string)
            const ranchDocRef = doc(this.getUserCollectionRef(userId, 'ranch'), 'data');
            await updateDoc(ranchDocRef, { ...updates, updatedAt: new Date() });
            const updatedRanch = (await getDoc(ranchDocRef)).data() as Ranch;
            return { ...updatedRanch, id: ranchDocRef.id };
          }

          // --- Lesson operations --- (Public data)
          async getAllLessons(): Promise<Lesson[]> {
            const snapshot = await getDocs(this.getPublicCollectionRef('lessons'));
            return snapshot.docs.map(doc => ({ ...doc.data(), id: parseInt(doc.id) })) as Lesson[]; // Parse doc.id to number
          }

          async getLessonById(id: number): Promise<Lesson | undefined> {
            const docRef = doc(this.getPublicCollectionRef('lessons'), id.toString());
            const docSnap = await getDoc(docRef);
            if (!docSnap.exists()) return undefined;
            return { ...docSnap.data(), id: parseInt(docSnap.id) } as Lesson;
          }

          async createLesson(lessonData: Omit<Lesson, 'id' | 'createdAt'>): Promise<Lesson> {
            // This method would typically be used by an admin to add lessons
            // For now, lessons are initialized in constructor
            throw new Error("createLesson not implemented for FirestoreStorage via API. Lessons are pre-initialized.");
          }

          // --- Lesson progress operations --- (User-specific data)
          async getLessonProgress(id: string): Promise<UserProgress | undefined> { // ID is Firestore doc ID
            // This method needs userId context to find the right collection
            throw new Error("getLessonProgress by id not fully implemented in context of user collections.");
          }

          async getLessonProgressByUserId(userId: string): Promise<UserProgress[]> {
            const q = query(this.getUserCollectionRef(userId, 'userProgress'));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id, completedAt: doc.data().completedAt?.toDate() })) as UserProgress[];
          }

          async getLessonProgressByUserAndLesson(userId: string, lessonId: number): Promise<UserProgress | undefined> {
            const q = query(this.getUserCollectionRef(userId, 'userProgress'), where('lessonId', '==', lessonId));
            const snapshot = await getDocs(q);
            if (snapshot.empty) return undefined;
            const docData = snapshot.docs[0].data();
            return { ...docData, id: snapshot.docs[0].id, completedAt: docData.completedAt?.toDate() } as UserProgress;
          }

          async createLessonProgress(insertProgress: InsertUserProgress): Promise<UserProgress> {
            const progressRef = collection(this.getUserCollectionRef(insertProgress.userId.toString(), 'userProgress'));
            const newProgressData = { ...insertProgress, completedAt: insertProgress.completed ? new Date() : null, createdAt: new Date() };
            const docRef = await addDoc(progressRef, newProgressData);
            const newProgress = (await getDoc(docRef)).data() as UserProgress;
            return { ...newProgress, id: docRef.id };
          }

          async updateLessonProgress(id: string, updates: Partial<Omit<UserProgress, 'id' | 'userId' | 'lessonId' | 'createdAt'>>): Promise<UserProgress> { // ID is string
            const currentUserId = updates.userId?.toString() || (await this.getAuthUserUid()); // Get user ID
            if (!currentUserId) throw new Error("User ID required to update lesson progress.");
            const progressRef = doc(this.getUserCollectionRef(currentUserId, 'userProgress'), id);
            await updateDoc(progressRef, { ...updates, completedAt: updates.completed ? new Date() : (await getDoc(progressRef)).data()?.completedAt });
            const updatedProgress = (await getDoc(progressRef)).data() as UserProgress;
            return { ...updatedProgress, id: progressRef.id };
          }

          // --- Character operations --- (User-specific data)
          async getCharacter(id: string): Promise<Character | undefined> { throw new Error("Method not implemented."); }
          async getCharactersByUserId(userId: string): Promise<Character[]> {
            const q = query(this.getUserCollectionRef(userId, 'characters'));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id })) as Character[];
          }

          async createCharacter(insertCharacter: InsertCharacter): Promise<Character> {
            const charRef = collection(this.getUserCollectionRef(insertCharacter.ownerId.toString(), 'characters'));
            const newCharData = { ...insertCharacter, level: 1, experience: 0, createdAt: new Date() };
            const docRef = await addDoc(charRef, newCharData);
            const newChar = (await getDoc(docRef)).data() as Character;
            return { ...newChar, id: docRef.id };
          }

          async updateCharacter(id: string, updates: Partial<Omit<Character, 'id' | 'ownerId' | 'createdAt'>>): Promise<Character> {
            const currentUserId = updates.ownerId?.toString() || (await this.getAuthUserUid());
            if (!currentUserId) throw new Error("User ID required to update character.");
            const charRef = doc(this.getUserCollectionRef(currentUserId, 'characters'), id);
            await updateDoc(charRef, updates);
            const updatedChar = (await getDoc(charRef)).data() as Character;
            return { ...updatedChar, id: charRef.id };
          }

          // --- Building operations --- (User-specific data linked via ranch)
          async getBuilding(id: string): Promise<Building | undefined> { throw new Error("Method not implemented."); }

          async getBuildingsByRanchId(ranchId: string): Promise<Building[]> { // ranchId here should be user's UID
              const q = query(this.getUserCollectionRef(ranchId, 'buildings'));
              const snapshot = await getDocs(q);
              return snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id })) as Building[];
          }
          async createBuilding(insertBuilding: InsertBuilding): Promise<Building> {
              const buildingRef = collection(this.getUserCollectionRef(insertBuilding.ranchId.toString(), 'buildings')); // ranchId is user's UID
              const newBuildingData = { ...insertBuilding, level: 1, metadata: insertBuilding.metadata || null, createdAt: new Date() };
              const docRef = await addDoc(buildingRef, newBuildingData);
              const newBuilding = (await getDoc(docRef)).data() as Building;
              return { ...newBuilding, id: docRef.id };
          }
          async updateBuilding(id: string, updates: Partial<Omit<Building, 'id' | 'ranchId' | 'createdAt'>>): Promise<Building> {
              const currentUserId = updates.ranchId?.toString() || (await this.getAuthUserUid());
              if (!currentUserId) throw new Error("User ID required to update building.");
              const buildingRef = doc(this.getUserCollectionRef(currentUserId, 'buildings'), id);
              await updateDoc(buildingRef, updates);
              const updatedBuilding = (await getDoc(buildingRef)).data() as Building;
              return { ...updatedBuilding, id: buildingRef.id };
          }

          // --- Reward NFT operations ---
          async getRewardNftsByUserId(userId: string): Promise<RewardNft[]> {
            const q = query(this.getUserCollectionRef(userId, 'rewardNfts'));
            const snapshot = await getDocs(q);
            return snapshot.docs.map(doc => ({ ...doc.data(), id: doc.id, awardedAt: doc.data().awardedAt?.toDate() })) as RewardNft[];
          }

          async createRewardNft(insertReward: InsertRewardNft): Promise<RewardNft> {
            const rewardRef = collection(this.getUserCollectionRef(insertReward.userId.toString(), 'rewardNfts'));
            const newRewardData = { ...insertReward, awardedAt: new Date() };
            const docRef = await addDoc(rewardRef, newRewardData);
            const newReward = (await getDoc(docRef)).data() as RewardNft;
            return { ...newReward, id: docRef.id };
          }

          // Helper to get authenticated user UID for server-side operations
          private async getAuthUserUid(): Promise<string | undefined> {
            const { getAuth } = await import("firebase/auth");
            const auth = getAuth(firebaseAppInstance);
            return auth.currentUser?.uid;
          }
        }

        export const storage = new FirestoreStorage();
        ```

**Phase 2: Fix `<a>` Nesting Warning in `Header.tsx` (CRITICAL HTML FIX)**

* **Objective:** Resolve the `<a> cannot appear as a descendant of <a>` warning by ensuring `Link` components from `wouter` are not nested.

1.  **Refactor `Header.tsx` Navigation:**
    * **File:** `client/src/components/layout/Header.tsx`
    * **Action:** Modify how navigation links are rendered to avoid nesting `<a>` tags.
    * **Implementation:**
        ```typescript
        // client/src/components/layout/Header.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        import { Link, useLocation } from 'wouter';
        import { WalletButton } from '../wallet/WalletButton';
        import { cn } from '@/lib/utils';

        export function Header() {
          const [location] = useLocation();

          const navItems = [
            { href: '/', label: 'Home' },
            { href: '/lessons', label: 'Lessons' },
            { href: '/playground', label: 'Playground' },
            { href: '/ranch', label: 'My Ranch' },
          ];

          return (
            <header className="relative z-50 border-b border-border/20 backdrop-blur-sm bg-background/80">
              <div className="container mx-auto px-4 py-6">
                <div className="flex items-center justify-between">
                  {/* Logo & Title */}
                  <Link href="/">
                    {/* Direct child of wouter's Link should be the clickable element (often <a>) */}
                    <a className="flex items-center space-x-4 cursor-pointer">
                      <div className="w-12 h-12 bg-gradient-tech rounded-lg flex items-center justify-center glow-tech-cyan animate-glow">
                        <span className="text-2xl">⚡</span>
                      </div>
                      <div>
                        <h1 className="text-4xl font-titulo text-tech-cyan">
                          BRB: A Solana Adventure
                        </h1>
                        <p className="text-sm text-tech-cyan font-tech mt-1">
                          Learn Solana • Build dApps • Master Web3 Development
                        </p>
                      </div>
                    </a>
                  </Link>

                  {/* Navigation */}
                  <nav className="hidden lg:flex items-center space-x-6">
                    {navItems.map(({ href, label }) => (
                      <Link key={href} href={href}>
                        {/* Direct child of wouter's Link should be the clickable element */}
                        <a
                          className={cn(
                            'font-tech text-sm uppercase tracking-wider transition-all duration-300 px-3 py-2 rounded-md',
                            location === href
                              ? 'text-tech-cyan bg-tech-cyan/10 border border-tech-cyan/30'
                              : 'text-foreground hover:text-tech-cyan hover:bg-tech-cyan/5'
                          )}
                        >
                          {label}
                        </a>
                      </Link>
                    ))}
                  </nav>

                  {/* Wallet Connection */}
                  <div className="flex items-center space-x-4">
                    <WalletButton />
                  </div>
                </div>
              </div>
            </header>
          );
        }
        ```

**Phase 3: Finalize Layout Overlap & Positioning Fixes (Re-application)**

* **Objective:** Ensure all UI elements are correctly spaced and positioned, preventing overlaps.

1.  **Refine `LessonLayout.tsx` Header & Main Content Flow (CRITICAL FIX):**
    * **File:** `client/src/components/lessons/LessonLayout.tsx`
    * **Action:** Ensure the fixed header pushes content down correctly and the layout is a proper flex column.
    * **Implementation:**
        * On the outermost `div` of `LessonLayout` (which currently has `min-h-screen bg-gradient-to-br ...`), **ensure** it has the Tailwind classes `flex flex-col`.
        * The `div` containing the `Progress Header` (`border-b border-border/20 ... sticky top-0 z-40`) **must** be changed from `sticky top-0 z-40` to `fixed top-0 left-0 right-0 z-40 w-full`. This will make it consistently fixed at the top and prevent content from scrolling under it.
        * Determine the actual height of this fixed header. Inspect the element in the browser's developer tools (after `fixed` is applied). Let's use `120px` as a robust estimate (including padding/margins).
        * Apply `padding-top` to the `<main>` element to push its content below the fixed header:
            ```html
            <main className="flex-grow pt-[120px] pb-[80px]"> {/* Add padding-bottom for fixed bottom nav */}
              {children}
            </main>
            ```
            * *Note:* The `pb-[80px]` is for the fixed bottom navigation bar (defined below).

2.  **Relocate Navigation Buttons to Bottom in `LessonLayout.tsx` (CRITICAL FIX):**
    * **File:** `client/src/components/lessons/LessonLayout.tsx`
    * **Action:** Move the "Previous" and "Next" buttons from the top header to a new fixed navigation bar at the bottom of the lesson content.
    * **Implementation:**
        * **Remove** the `div` containing the "Previous" and "Next" buttons from the `Progress Header` section at the top.
        * Create a **new `div`** at the very bottom of the `LessonLayout.tsx` component, just before its closing `</div>` tag. This `div` will serve as the bottom navigation bar.
        * Give this new `div` the following classes:
            ```html
            {/* NEW: Fixed Bottom Navigation Bar (COPY THIS ENTIRE BLOCK) */}
            <div className="fixed bottom-0 left-0 right-0 z-40 w-full
                            flex items-center justify-between px-4 py-4
                            bg-background/80 backdrop-blur-sm
                            border-t border-border/20">
              {/* Previous Button */}
              <Button
                onClick={onPrevious}
                disabled={!hasPrevious}
                variant="outline"
                size="sm"
                className="text-xs"
              >
                <ChevronLeft className="w-4 h-4 mr-1" />
                Previous
              </Button>
              {/* Next Button */}
              <Button
                onClick={onNext}
                disabled={nextButtonDisabled} {/* Use the disabled state calculated in LDP */}
                variant="default"
                size="sm"
                className="tech-button tech-button-primary text-xs"
              >
                {nextButtonText || 'Next'} {/* Use the new prop */}
                <ChevronRight className="w-4 h-4 ml-1" />
              </Button>
            </div>
            ```
        * Ensure `TechButton` (which should be implemented in Phase 4) and `Button` imports are correct.

3.  **Verify `MainLayout.tsx` Footer Positioning (CRITICAL FIX):**
    * **File:** `client/src/components/layout/MainLayout.tsx`
    * **Action:** Confirm the "sticky footer" pattern is correctly implemented.
    * **Implementation:**
        * Ensure the outermost `div` (`min-h-screen bg-gradient-to-br ...`) **definitively** has the Tailwind classes `flex flex-col`.
        * Ensure the `<main>` element (`relative z-10`) **definitively** has `flex-grow`.
        * The footer should now automatically be pushed to the bottom. Review the `mt-` (margin-top) class on the `<footer>` element. If it's `mt-20`, try reducing it to `mt-10` or `mt-8` for a more compact appearance.

**Phase 4: Implement Missing Components & Logic (Reward, Hint, PIXI.js, Console Polish)**

* **Objective:** Implement the visual reward system, the interactive hint character, begin PIXI.js refactoring for `GameCanvas`, and finalize console output improvements.

1.  **Implement `ChallengeReward.tsx` Component:**
    * **File:** `client/src/components/game/ChallengeReward.tsx` (new file)
    * **Action:** Create a full-screen overlay component for "CORRECT" text and animated NFT.
    * **Implementation:**
        ```typescript
        // client/src/components/game/ChallengeReward.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        'use client';
        import React, { useEffect, useState } from 'react';
        import { motion, AnimatePresence } from 'framer-motion';
        import { cn } from '@/lib/utils'; // Assuming cn utility is available

        interface ChallengeRewardProps {
          isVisible: boolean;
          nftImageUrl: string | null;
        }

        export const ChallengeReward: React.FC<ChallengeRewardProps> = ({ isVisible, nftImageUrl }) => {
          const [showContent, setShowContent] = useState(false);

          useEffect(() => {
            if (isVisible) {
              setShowContent(true);
              const timer = setTimeout(() => {
                setShowContent(false);
              }, 3500); // Display for 3.5 seconds
              return () => clearTimeout(timer);
            }
          }, [isVisible]);

          return (
            <AnimatePresence>
              {showContent && isVisible && (
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  className="fixed inset-0 z-[100] flex flex-col items-center justify-center pointer-events-none
                             bg-black/70 backdrop-blur-sm px-4 py-8"
                >
                  <motion.h1
                    initial={{ opacity: 0, scale: 0.5 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.5 }}
                    transition={{ duration: 0.5, ease: "easeOut" }}
                    className="text-8xl md:text-9xl font-titulo text-tech-cyan text-shadow-matrix mb-8 md:mb-12"
                  >
                    CORRECT
                  </motion.h1>

                  {nftImageUrl && (
                    <motion.div
                      initial={{ opacity: 0, y: 50, scale: 0.7 }}
                      animate={{ opacity: 1, y: 0, scale: 1 }}
                      exit={{ opacity: 0, y: -50, scale: 0.7 }}
                      transition={{ delay: 0.2, duration: 0.5, ease: "easeOut" }}
                      className="relative w-48 h-48 md:w-64 md:h-64 flex items-center justify-center p-4 rounded-xl shadow-lg glow-tech-cyan
                                 bg-gradient-to-br from-tech-purple/20 to-tech-pink/20 border-2 border-tech-cyan"
                    >
                      <img
                        src={nftImageUrl}
                        alt="Reward NFT"
                        className="w-full h-full object-contain rounded-md"
                        onError={(e) => { e.currentTarget.src = '[https://placehold.co/256x256/3a3340/99cccc?text=NFT+Error](https://placehold.co/256x256/3a3340/99cccc?text=NFT+Error)'; }}
                      />
                       <span className="absolute bottom-2 text-tech-cyan font-tech text-sm">Reward Unlocked!</span>
                    </motion.div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          );
        };
        ```

2.  **Implement `HintCharacter.tsx` Component:**
    * **File:** `client/src/components/lessons/HintCharacter.tsx` (new file)
    * **Action:** Create a reusable component for character-based pop-up hints.
    * **Implementation:**
        ```typescript
        // client/src/components/lessons/HintCharacter.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        'use client';
        import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
        import { motion, AnimatePresence } from 'framer-motion';
        import { cn } from '@/lib/utils'; // Assuming cn utility is available

        interface HintCharacterProps {
          characterImage?: string;
        }

        export interface HintCharacterRef {
          showHint: (message: string) => void;
        }

        export const HintCharacter = forwardRef<HintCharacterRef, HintCharacterProps>(
          ({ characterImage = '/assets/images/scientist-character.png' }, ref) => {
            const [isVisible, setIsVisible] = useState(false);
            const [message, setMessage] = useState('');
            const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null>(null);

            useImperativeHandle(ref, () => ({
              showHint: (msg: string) => {
                if (timeoutId) clearTimeout(timeoutId); // Clear any existing hint
                setMessage(msg);
                setIsVisible(true);
                const id = setTimeout(() => {
                  setIsVisible(false);
                  setMessage('');
                }, 7000); // Hint displayed for 7 seconds
                setTimeoutId(id);
              },
            }));

            // Preload image
            useEffect(() => {
              const img = new Image();
              img.src = characterImage;
            }, [characterImage]);

            return (
              <AnimatePresence>
                {isVisible && (
                  <motion.div
                    initial={{ opacity: 0, x: -100 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -100 }}
                    transition={{ type: "spring", stiffness: 100, damping: 15 }}
                    className="fixed bottom-4 left-4 z-[90] flex items-end space-x-4 pointer-events-auto"
                  >
                    <motion.img
                      src={characterImage}
                      alt="AI Assistant"
                      className="w-28 h-28 object-contain"
                      initial={{ rotate: 0 }}
                      animate={{ rotate: [0, -5, 5, -5, 0] }} // Subtle idle animation
                      transition={{ repeat: Infinity, duration: 5, ease: "easeInOut" }}
                    />
                    <motion.div
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: 20 }}
                      transition={{ delay: 0.2, type: "spring", stiffness: 100, damping: 15 }}
                      className="relative bg-tech-cyan rounded-xl p-4 text-background font-tech text-base max-w-sm shadow-lg
                                 before:absolute before:bottom-0 before:left-[10px] before:w-0 before:h-0
                                 before:border-x-[15px] before:border-t-[15px] before:border-solid before:border-transparent
                                 before:border-t-tech-cyan before:transform before:translate-y-full"
                    >
                      {message}
                    </motion.div>
                  </motion.div>
                )}
              </AnimatePresence>
            );
          }
        );
        HintCharacter.displayName = 'HintCharacter';
        ```

3.  **Refactor `GameCanvas.tsx` to use PIXI.js (CRITICAL VISUAL UPGRADE):**
    * **File:** `client/src/components/game/GameCanvas.tsx`
    * **Action:** Replace all raw Canvas2D drawing (`ctx.fillRect`, `ctx.arc`, `ctx.fillText`) with `PIXI.js` objects. Implement PIXI.js rendering for all static and dynamic elements, and add `dataStream` visual effect.
    * **Implementation:**
        ```typescript
        // client/src/components/game/GameCanvas.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        'use client';
        import React, { useRef, useEffect, useState } from 'react';
        import * as PIXI from 'pixi.js';
        import { useGameStore } from '@/hooks/use-game-store'; // Ensure correct path
        import { cn } from '@/lib/utils';

        // Interface for GameCanvas props
        interface GameCanvasProps {
          width?: number;
          height?: number;
          className?: string;
          // Visual effect flags passed from useGameStore
          networkPingActive?: boolean;
          sparkleActive?: boolean;
          coinFallActive?: boolean;
          lastStoredMessage?: string | null;
          transactionActive?: boolean;
          dataStreamActive?: boolean; // For PDA challenge
        }

        // Main GameCanvas component
        export function GameCanvas({
          width = 800,
          height = 400,
          className,
          networkPingActive,
          sparkleActive,
          coinFallActive,
          lastStoredMessage,
          transactionActive,
          dataStreamActive,
        }: GameCanvasProps) {
          const canvasRef = useRef<HTMLDivElement>(null); // Ref for the container div
          const appRef = useRef<PIXI.Application | null>(null); // Ref for the PIXI Application
          const [isLoaded, setIsLoaded] = useState(false);
          const { ranchData, characters, buildings } = useGameStore(); // Game state from Zustand

          // Master useEffect for PIXI application lifecycle
          useEffect(() => {
            if (!canvasRef.current) return;

            // Initialize PIXI application
            const app = new PIXI.Application({
              width,
              height,
              backgroundColor: 0x1A237E, // Dark tech blue from theme (mystic-900)
              antialias: true,
              autoDensity: true, // For high DPI screens
              resolution: window.devicePixelRatio || 1,
            });

            appRef.current = app; // Store app instance in ref
            canvasRef.current.appendChild(app.view as HTMLCanvasElement); // Append PIXI canvas to the div

            // Load assets and set up initial scene
            const setupScene = async () => {
              // Preload assets (e.g., character sprites, building textures)
              // For now, using simple shapes/emojis as placeholders, but this is where real assets would load.
              // Example for future: await PIXI.Assets.load('path/to/character.png');

              // Create background layers
              createBackground(app);

              // Create static ranch elements
              createRanchBase(app);

              // Add UI elements that are part of the PIXI scene (if any, like resource counters)
              // For now, resource counters are HTML overlay.

              setIsLoaded(true);
            };

            setupScene();

            // Cleanup function: destroy PIXI app on component unmount
            return () => {
              if (appRef.current) {
                appRef.current.destroy(true); // Destroy PIXI app and its view
                appRef.current = null;
              }
            };
          }, [width, height]); // Re-run if canvas dimensions change

          // Effect for updating scene based on game state and visual effect flags
          useEffect(() => {
            if (!appRef.current || !isLoaded) return;
            const app = appRef.current;

            // Clear previous dynamic elements (e.g., characters, temporary effects)
            app.stage.children.forEach(child => {
                if (child.name && (child.name.startsWith('character_') || child.name.startsWith('building_dynamic_') || child.name.startsWith('effect_'))) {
                    app.stage.removeChild(child);
                    child.destroy();
                }
            });

            // Re-draw dynamic elements based on current game state
            updateRanchElements(app);

            // Trigger and manage transient visual effects
            manageVisualEffects(app, {
              networkPingActive, sparkleActive, coinFallActive,
              lastStoredMessage, transactionActive, dataStreamActive,
            });

          }, [ranchData, characters, buildings, isLoaded,
              networkPingActive, sparkleActive, coinFallActive,
              lastStoredMessage, transactionActive, dataStreamActive]); // Depend on relevant states/props


          // --- PIXI.js Scene Creation Functions ---

          const createBackground = (app: PIXI.Application) => {
            // Sky Gradient
            const sky = new PIXI.Graphics();
            sky.beginFill(0x303F9F); // Darker tech blue (mystic-700)
            sky.drawRect(0, 0, app.screen.width, app.screen.height * 0.7);
            sky.endFill();
            app.stage.addChild(sky);

            // Ground/Horizon
            const ground = new PIXI.Graphics();
            ground.beginFill(0x4E342E); // Dark leather brown
            ground.drawRect(0, app.screen.height * 0.7, app.screen.width, app.screen.height * 0.3);
            ground.endFill();
            app.stage.addChild(ground);

            // Distant Cypher-Punk Cityscape (using Graphics for simplicity)
            const cityscape = new PIXI.Graphics();
            cityscape.beginFill(0x882895, 0.4); // Tech purple with transparency
            cityscape.moveTo(0, app.screen.height * 0.6);
            cityscape.lineTo(app.screen.width * 0.1, app.screen.height * 0.4);
            cityscape.lineTo(app.screen.width * 0.2, app.screen.height * 0.5);
            cityscape.lineTo(app.screen.width * 0.3, app.screen.height * 0.35);
            cityscape.lineTo(app.screen.width * 0.4, app.screen.height * 0.55);
            cityscape.lineTo(app.screen.width * 0.5, app.screen.height * 0.4);
            cityscape.lineTo(app.screen.width * 0.6, app.screen.height * 0.5);
            cityscape.lineTo(app.screen.width * 0.7, app.screen.height * 0.3);
            cityscape.lineTo(app.screen.width * 0.8, app.screen.height * 0.5);
            cityscape.lineTo(app.screen.width * 0.9, app.screen.height * 0.4);
            cityscape.lineTo(app.screen.width, app.screen.height * 0.55);
            cityscape.lineTo(app.screen.width, app.screen.height * 0.7);
            cityscape.lineTo(0, app.screen.height * 0.7);
            cityscape.closePath();
            cityscape.endFill();
            app.stage.addChild(cityscape);
          };

          const createRanchBase = (app: PIXI.Application) => {
            // Static ranch elements like main entrance, fences that are always there
            const fence = new PIXI.Graphics();
            fence.lineStyle(4, 0x5D4037); // Darker leather brown
            fence.moveTo(50, app.screen.height * 0.85);
            fence.lineTo(app.screen.width - 50, app.screen.height * 0.85);
            for (let x = 50; x < app.screen.width - 50; x += 100) {
              fence.moveTo(x, app.screen.height * 0.85 - 30);
              fence.lineTo(x, app.screen.height * 0.85 + 10);
            }
            app.stage.addChild(fence);

            // Ranch Sign
            const signContainer = new PIXI.Container();
            const post = new PIXI.Graphics();
            post.beginFill(0x5D4037);
            post.drawRect(-5, 0, 10, 80);
            post.endFill();
            const board = new PIXI.Graphics();
            board.beginFill(0x161020); // Dark tech card background
            board.lineStyle(2, 0x08ddb8); // Tech cyan border
            board.drawRoundedRect(-60, -20, 120, 40, 5);
            board.endFill();
            const text = new PIXI.Text('SHADOW RANCH', {
              fontFamily: 'Orbitron', // Tech font
              fontSize: 12,
              fill: 0x08ddb8, // Tech cyan
              fontWeight: 'bold',
            });
            text.anchor.set(0.5);
            signContainer.addChild(post);
            signContainer.addChild(board);
            signContainer.addChild(text);
            signContainer.x = 120;
            signContainer.y = app.screen.height * 0.75;
            app.stage.addChild(signContainer);
          };

          const updateRanchElements = (app: PIXI.Application) => {
            // Render collected buildings (use actual sprites for each type later)
            buildings.forEach((building, index) => {
              const buildingSprite = new PIXI.Graphics();
              buildingSprite.beginFill(0x882895); // Tech purple
              buildingSprite.drawRect(0, 0, 80, 60); // Simple rectangle for now
              buildingSprite.endFill();
              buildingSprite.x = 200 + index * 100;
              buildingSprite.y = app.screen.height * 0.6 - 60;
              buildingSprite.name = `building_dynamic_${building.id}`; // Give it a unique name
              app.stage.addChild(buildingSprite);

              const roof = new PIXI.Graphics();
              roof.beginFill(0x654321); // Dark brown for contrast, can be changed to tech
              roof.moveTo(0, 0);
              roof.lineTo(40, -20);
              roof.lineTo(80, 0);
              roof.closePath();
              roof.endFill();
              roof.x = buildingSprite.x;
              roof.y = buildingSprite.y;
              buildingSprite.addChild(roof); // Add roof to building sprite/container
            });

            // Render characters (use actual sprites for each type later)
            characters.slice(0, 3).forEach((character, index) => { // Limit for performance if many
              const characterText = new PIXI.Text('🧑‍💻', { // Cypher-punk character emoji
                fontFamily: 'Arial',
                fontSize: 30,
                fill: 0x2ae6c4, // Light tech cyan
              });
              characterText.anchor.set(0.5);
              characterText.x = 350 + index * 80 + Math.sin(Date.now() * 0.005 + index) * 10; // Simple idle animation
              characterText.y = app.screen.height * 0.75;
              characterText.name = `character_${character.id}`;
              app.stage.addChild(characterText);
            });

            // Render last stored message (if active)
            if (lastStoredMessage) {
              const messageBoardContainer = new PIXI.Container();
              messageBoardContainer.name = 'effect_messageBoard';
              const boardX = 50;
              const boardY = app.screen.height * 0.5;
              const boardWidth = 150;
              const boardHeight = 60;

              const post = new PIXI.Graphics();
              post.beginFill(0x5D4037);
              post.drawRect(boardWidth / 2 - 5, 0, 10, 40);
              post.endFill();

              const board = new PIXI.Graphics();
              board.beginFill(0x161020); // Dark tech background
              board.lineStyle(2, 0x08ddb8); // Tech cyan border
              board.drawRoundedRect(0, 0, boardWidth, boardHeight, 5);
              board.endFill();

              const messageText = new PIXI.Text(lastStoredMessage, {
                fontFamily: 'Fira Code', // Monospace for code/data
                fontSize: 10,
                fill: 0x2ae6c4, // Light tech cyan
                wordWrap: true,
                wordWrapWidth: boardWidth - 10,
                align: 'center',
              });
              messageText.anchor.set(0.5);
              messageText.x = boardWidth / 2;
              messageText.y = boardHeight / 2;

              messageBoardContainer.addChild(post);
              messageBoardContainer.addChild(board);
              messageBoardContainer.addChild(messageText);
              messageBoardContainer.x = boardX;
              messageBoardContainer.y = boardY;
              app.stage.addChild(messageBoardContainer);
            }
          };

          // --- Transient Visual Effects Management ---
          const manageVisualEffects = (app: PIXI.Application, effects: any) => {
            // Remove previous transient effects
            app.stage.children.forEach(child => {
                if (child.name && child.name.startsWith('transient_effect_')) {
                    app.stage.removeChild(child);
                    child.destroy();
                }
            });

            if (effects.networkPingActive) {
                // Network Ping Effect (pulsing circle)
                const ping = new PIXI.Graphics();
                ping.name = 'transient_effect_networkPing';
                ping.x = app.screen.width / 2;
                ping.y = app.screen.height * 0.4;
                app.stage.addChild(ping);

                let radius = 0;
                let alpha = 1;
                app.ticker.add(() => {
                    if (!effects.networkPingActive) { app.ticker.remove(this); return; }
                    radius += 1;
                    alpha -= 0.01;
                    ping.clear();
                    ping.lineStyle(3, 0x00FF00, alpha); // Green, fading
                    ping.drawCircle(0, 0, radius);
                    if (alpha <= 0) {
                        ping.destroy();
                        app.ticker.remove(this); // Remove self from ticker
                    }
                });
            }

            if (effects.sparkleActive) {
                // Sparkle Effect (random small dots)
                const sparkleContainer = new PIXI.Container();
                sparkleContainer.name = 'transient_effect_sparkle';
                app.stage.addChild(sparkleContainer);

                for (let i = 0; i < 20; i++) {
                    const s = new PIXI.Graphics();
                    s.beginFill(0xFFFFCC, Math.random()); // Light yellow, random alpha
                    s.drawCircle(0, 0, Math.random() * 3 + 1);
                    s.endFill();
                    s.x = Math.random() * app.screen.width;
                    s.y = Math.random() * app.screen.height * 0.7;
                    sparkleContainer.addChild(s);

                    // Animate sparkle fading and shrinking
                    app.ticker.add(() => {
                        if (!effects.sparkleActive) { sparkleContainer.destroy(); app.ticker.remove(this); return; }
                        s.alpha -= 0.05;
                        s.scale.x = s.scale.y = s.alpha;
                        if (s.alpha <= 0) { s.destroy(); }
                    });
                }
            }

            if (effects.coinFallActive) {
                // Coin Fall Effect
                const coinContainer = new PIXI.Container();
                coinContainer.name = 'transient_effect_coinFall';
                app.stage.addChild(coinContainer);

                for (let i = 0; i < 15; i++) {
                    const coin = new PIXI.Text('💎', { // Diamond emoji for cypher-punk coin
                        fontFamily: 'Arial',
                        fontSize: 20,
                    });
                    coin.anchor.set(0.5);
                    coin.x = Math.random() * app.screen.width;
                    coin.y = -coin.height - (Math.random() * 100); // Start above canvas
                    coinContainer.addChild(coin);

                    app.ticker.add(() => {
                        if (!effects.coinFallActive) { coinContainer.destroy(); app.ticker.remove(this); return; }
                        coin.y += 5; // Fall speed
                        if (coin.y > app.screen.height * 0.75) {
                            coin.alpha -= 0.1; // Fade out upon landing
                        }
                        if (coin.alpha <= 0) { coin.destroy(); }
                    });
                }
            }

            if (effects.transactionActive) {
                // Transaction Animation (bounty bag/data packet)
                const packet = new PIXI.Text('📦', { // Package emoji
                    fontFamily: 'Arial',
                    fontSize: 30,
                });
                packet.name = 'transient_effect_transaction';
                packet.anchor.set(0.5);
                packet.x = app.screen.width * 0.2; // Start from ranch
                packet.y = app.screen.height * 0.7;
                app.stage.addChild(packet);

                let progress = 0;
                app.ticker.add((delta) => {
                    if (!effects.transactionActive) { packet.destroy(); app.ticker.remove(this); return; }
                    progress += 0.005 * delta; // Speed of travel
                    packet.x = app.screen.width * 0.2 + (app.screen.width * 0.6) * progress;
                    packet.y = app.screen.height * 0.7 - Math.sin(progress * Math.PI) * 50; // Arc movement
                    packet.alpha = 1 - progress; // Fade out

                    if (progress >= 1) {
                        packet.destroy();
                        app.ticker.remove(this);
                    }
                });
            }

            if (effects.dataStreamActive) {
                // Data Stream Effect (for PDA success)
                const streamContainer = new PIXI.Container();
                streamContainer.name = 'transient_effect_dataStream';
                app.stage.addChild(streamContainer);

                for (let i = 0; i < 40; i++) {
                    const dataBit = new PIXI.Graphics();
                    dataBit.beginFill(0x08DDB8, Math.random()); // Tech cyan, random alpha
                    dataBit.drawRect(0, 0, 3, 3); // Small square data bit
                    dataBit.endFill();

                    // Random start position near top of ranch, subtle movement
                    dataBit.x = Math.random() * (app.screen.width * 0.6) + app.screen.width * 0.2;
                    dataBit.y = Math.random() * (app.screen.height * 0.2) + app.screen.height * 0.5;
                    dataBit.speedY = Math.random() * 2 + 0.5; // Varying fall speed
                    dataBit.alpha = Math.random();
                    streamContainer.addChild(dataBit);
                }

                app.ticker.add(() => {
                    if (!effects.dataStreamActive) { streamContainer.destroy(); app.ticker.remove(this); return; }
                    streamContainer.children.forEach((bit: any) => {
                        bit.y += bit.speedY; // Move downwards
                        bit.alpha -= 0.005; // Slowly fade out

                        if (bit.y > app.screen.height || bit.alpha <= 0) {
                            bit.x = Math.random() * (app.screen.width * 0.6) + app.screen.width * 0.2;
                            bit.y = Math.random() * (app.screen.height * 0.1) + app.screen.height * 0.5; // Reset to top
                            bit.alpha = 1;
                            bit.speedY = Math.random() * 2 + 0.5;
                        }
                    });
                });
            }
          };

          return (
            <div className={cn('relative ranch-canvas overflow-hidden', className)}>
              <div ref={canvasRef} className="w-full h-full" />
              {!isLoaded && (
                <div className="absolute inset-0 flex items-center justify-center bg-background">
                  <div className="text-tech-cyan font-tech">Loading Cypher-Ranch...</div>
                </div>
              )}

              {/* UI Overlay for Ranch Info (kept as HTML for easy styling) */}
              <div className="absolute top-4 right-4 space-y-2">
                <div className="bg-black/70 backdrop-blur-sm px-3 py-1 rounded-full text-tech-cyan text-sm font-code border border-tech-cyan/30">
                  💎 {ranchData.ranchCoinBalance} DevCoin
                </div>
                <div className="bg-black/70 backdrop-blur-sm px-3 py-1 rounded-full text-tech-cyan text-sm font-code border border-tech-cyan/30">
                  🧑‍💻 {characters.length} Agents
                </div>
                <div className="bg-black/70 backdrop-blur-sm px-3 py-1 rounded-full text-tech-cyan text-sm font-code border border-tech-cyan/30">
                  🏛️ {buildings.length} Structures
                </div>
              </div>

              {/* Progress Bar (kept as HTML overlay) */}
              <div className="absolute bottom-4 left-4 right-4">
                <div className="bg-black/70 backdrop-blur-sm px-4 py-2 rounded-lg border border-tech-purple/30">
                  <div className="flex items-center justify-between text-tech-cyan text-sm font-tech mb-2">
                    <span>Ranch Progress</span>
                    <span>Level {ranchData.level}</span>
                  </div>
                  <div className="w-full bg-gray-700 rounded-full h-2">
                    <div
                      className="bg-gradient-to-r from-tech-purple to-tech-pink h-2 rounded-full transition-all duration-500"
                      style={{ width: `${(ranchData.experience % 500) / 5}%` }}
                    />
                  </div>
                </div>
              </div>
            </div>
          );
        }
        ```

4.  **Implement `ChallengeReward.tsx` Component:**
    * **File:** `client/src/components/game/ChallengeReward.tsx` (new file)
    * **Action:** Create a full-screen overlay component for "CORRECT" text and animated NFT.
    * **Implementation:**
        ```typescript
        // client/src/components/game/ChallengeReward.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        'use client';
        import React, { useEffect, useState } from 'react';
        import { motion, AnimatePresence } from 'framer-motion';
        import { cn } from '@/lib/utils'; // Assuming cn utility is available

        interface ChallengeRewardProps {
          isVisible: boolean;
          nftImageUrl: string | null;
        }

        export const ChallengeReward: React.FC<ChallengeRewardProps> = ({ isVisible, nftImageUrl }) => {
          const [showContent, setShowContent] = useState(false);

          useEffect(() => {
            if (isVisible) {
              setShowContent(true);
              const timer = setTimeout(() => {
                setShowContent(false);
              }, 3500); // Display for 3.5 seconds
              return () => clearTimeout(timer);
            }
          }, [isVisible]);

          return (
            <AnimatePresence>
              {showContent && isVisible && (
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  className="fixed inset-0 z-[100] flex flex-col items-center justify-center pointer-events-none
                             bg-black/70 backdrop-blur-sm px-4 py-8"
                >
                  <motion.h1
                    initial={{ opacity: 0, scale: 0.5 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.5 }}
                    transition={{ duration: 0.5, ease: "easeOut" }}
                    className="text-8xl md:text-9xl font-titulo text-tech-cyan text-shadow-matrix mb-8 md:mb-12"
                  >
                    CORRECT
                  </motion.h1>

                  {nftImageUrl && (
                    <motion.div
                      initial={{ opacity: 0, y: 50, scale: 0.7 }}
                      animate={{ opacity: 1, y: 0, scale: 1 }}
                      exit={{ opacity: 0, y: -50, scale: 0.7 }}
                      transition={{ delay: 0.2, duration: 0.5, ease: "easeOut" }}
                      className="relative w-48 h-48 md:w-64 md:h-64 flex items-center justify-center p-4 rounded-xl shadow-lg glow-tech-cyan
                                 bg-gradient-to-br from-tech-purple/20 to-tech-pink/20 border-2 border-tech-cyan"
                    >
                      <img
                        src={nftImageUrl}
                        alt="Reward NFT"
                        className="w-full h-full object-contain rounded-md"
                        onError={(e) => { e.currentTarget.src = '[https://placehold.co/256x256/3a3340/99cccc?text=NFT+Error](https://placehold.co/256x256/3a3340/99cccc?text=NFT+Error)'; }}
                      />
                       <span className="absolute bottom-2 text-tech-cyan font-tech text-sm">Reward Unlocked!</span>
                    </motion.div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          );
        };
        ```

5.  **Implement `HintCharacter.tsx` Component:**
    * **File:** `client/src/components/lessons/HintCharacter.tsx` (new file)
    * **Action:** Create a reusable component for character-based pop-up hints.
    * **Implementation:**
        ```typescript
        // client/src/components/lessons/HintCharacter.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        'use client';
        import React, { useState, useEffect, forwardRef, useImperativeHandle } from 'react';
        import { motion, AnimatePresence } from 'framer-motion';
        import { cn } from '@/lib/utils'; // Assuming cn utility is available

        interface HintCharacterProps {
          characterImage?: string;
        }

        export interface HintCharacterRef {
          showHint: (message: string) => void;
        }

        export const HintCharacter = forwardRef<HintCharacterRef, HintCharacterProps>(
          ({ characterImage = '/assets/images/scientist-character.png' }, ref) => {
            const [isVisible, setIsVisible] = useState(false);
            const [message, setMessage] = useState('');
            const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null>(null);

            useImperativeHandle(ref, () => ({
              showHint: (msg: string) => {
                if (timeoutId) clearTimeout(timeoutId); // Clear any existing hint
                setMessage(msg);
                setIsVisible(true);
                const id = setTimeout(() => {
                  setIsVisible(false);
                  setMessage('');
                }, 7000); // Hint displayed for 7 seconds
                setTimeoutId(id);
              },
            }));

            // Preload image
            useEffect(() => {
              const img = new Image();
              img.src = characterImage;
            }, [characterImage]);

            return (
              <AnimatePresence>
                {isVisible && (
                  <motion.div
                    initial={{ opacity: 0, x: -100 }}
                    animate={{ opacity: 1, x: 0 }}
                    exit={{ opacity: 0, x: -100 }}
                    transition={{ type: "spring", stiffness: 100, damping: 15 }}
                    className="fixed bottom-4 left-4 z-[90] flex items-end space-x-4 pointer-events-auto"
                  >
                    <motion.img
                      src={characterImage}
                      alt="AI Assistant"
                      className="w-28 h-28 object-contain"
                      initial={{ rotate: 0 }}
                      animate={{ rotate: [0, -5, 5, -5, 0] }} // Subtle idle animation
                      transition={{ repeat: Infinity, duration: 5, ease: "easeInOut" }}
                    />
                    <motion.div
                      initial={{ opacity: 0, y: 20 }}
                      animate={{ opacity: 1, y: 0 }}
                      exit={{ opacity: 0, y: 20 }}
                      transition={{ delay: 0.2, type: "spring", stiffness: 100, damping: 15 }}
                      className="relative bg-tech-cyan rounded-xl p-4 text-background font-tech text-base max-w-sm shadow-lg
                                 before:absolute before:bottom-0 before:left-[10px] before:w-0 before:h-0
                                 before:border-x-[15px] before:border-t-[15px] before:border-solid before:border-transparent
                                 before:border-t-tech-cyan before:transform before:translate-y-full"
                    >
                      {message}
                    </motion.div>
                  </motion.div>
                )}
              </AnimatePresence>
            );
          }
        );
        HintCharacter.displayName = 'HintCharacter';
        ```

**Phase 2: Frontend Data Store Migration to Firestore (Hooks & Components)**

* **Objective:** Modify `useLessonStore` and `useGameStore` to read from and write to Firestore, ensuring data persistence.

1.  **Modify `client/src/hooks/use-lesson-store.ts`:**
    * **File:** `client/src/hooks/use-lesson-store.ts`
    * **Action:** Replace `localStorage` with Firestore operations.
    * **Implementation:**
        ```typescript
        // client/src/hooks/use-lesson-store.ts - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        import { useState, useEffect } from 'react';
        import { lessons, type LessonData, LessonStep } from '../data/lessons'; // Import LessonStep
        import { getFirestore, collection, query, where, onSnapshot, doc, setDoc, addDoc, getDoc } from 'firebase/firestore';
        import { getAuth } from 'firebase/auth';
        import { appId } from '../firebase-init'; // Import appId from centralized init

        export interface LessonProgress {
          lessonId: number;
          completed: boolean;
          score: number;
          timeSpent: number;
          attempts: number;
          completedAt?: Date;
          userId: string; // Ensure userId is always here
          id?: string; // Firestore uses string IDs
        }

        export function useLessonStore() {
          const [progress, setProgress] = useState<LessonProgress[]>([]);
          const [currentLesson, setCurrentLesson] = useState<number>(1);
          const [userId, setUserId] = useState<string | null>(null);
          const [isStoreReady, setIsStoreReady] = useState(false);

          useEffect(() => {
            const auth = getAuth();
            const firestoreDb = getFirestore();

            const unsubscribeAuth = onAuthStateChanged(auth, async (user) => {
              const currentUid = user?.uid; // Use actual UID
              if (!currentUid) {
                // If no authenticated user, try anonymous or generate random ID for session
                // For this, we MUST have a user UID for Firestore paths.
                // Assuming MainLayout handles initial anonymous sign-in or custom token sign-in,
                // so user.uid should be available here. If not, this needs attention.
                console.warn("No authenticated user UID available in useLessonStore. Data might not persist.");
                setIsStoreReady(false); // Mark not ready if no user
                return;
              }
              setUserId(currentUid);

              if (firestoreDb && currentUid) {
                // Fetch current_lesson from Firestore or default to 1
                const userDocRef = doc(firestoreDb, `artifacts/${appId}/users/${currentUid}/profile/data`);
                const userDocSnap = await getDoc(userDocRef);
                if (userDocSnap.exists()) {
                  const userData = userDocSnap.data();
                  setCurrentLesson(userData.currentLesson || 1);
                } else {
                  // Create basic user profile if it doesn't exist
                  await setDoc(userDocRef, { currentLesson: 1, createdAt: new Date() }, { merge: true });
                  setCurrentLesson(1);
                }

                // Set up real-time listener for user progress
                const q = query(collection(firestoreDb, `artifacts/${appId}/users/${currentUid}/userProgress`));
                const unsubscribeProgress = onSnapshot(q, (snapshot) => {
                  const fetchedProgress: LessonProgress[] = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data() as Omit<LessonProgress, 'id'>,
                    completedAt: doc.data().completedAt?.toDate(), // Convert Firestore Timestamp to Date
                  }));
                  setProgress(fetchedProgress);
                  setIsStoreReady(true);
                });

                return () => unsubscribeProgress(); // Cleanup listener
              }
            });

            return () => unsubscribeAuth();
          }, []); // Empty dependency array means this runs once on mount

          const getLessonProgress = (lessonId: number): LessonProgress | undefined => {
            return progress.find(p => p.lessonId === lessonId);
          };

          const completeLesson = async (lessonId: number, score: number, timeSpent: number) => {
            if (!userId || !db) return;
            const existingProgress = progress.find(p => p.lessonId === lessonId);
            const progressRef = collection(db, `artifacts/${appId}/users/${userId}/userProgress`);

            const newProgressData: Omit<LessonProgress, 'id'> = { // Exclude 'id' for addDoc
              lessonId,
              completed: true,
              score: Math.max(score, existingProgress?.score || 0),
              timeSpent: (existingProgress?.timeSpent || 0) + timeSpent,
              attempts: (existingProgress?.attempts || 0) + 1,
              completedAt: new Date(),
              userId: userId,
            };

            if (existingProgress?.id) {
              // Update existing document
              await setDoc(doc(progressRef, existingProgress.id), newProgressData, { merge: true });
            } else {
              // Add new document
              await addDoc(progressRef, newProgressData);
            }

            // Update current_lesson in user profile (separate document)
            const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/profile/data`);
            const nextLesson = lessonId + 1; // Always increment for next lesson
            await setDoc(userDocRef, { currentLesson: nextLesson }, { merge: true });
            setCurrentLesson(nextLesson);
          };

          const updateLessonAttempt = async (lessonId: number, timeSpent: number) => {
            if (!userId || !db) return;
            const existingProgress = progress.find(p => p.lessonId === lessonId);
            const progressRef = collection(db, `artifacts/${appId}/users/${userId}/userProgress`);

            const newProgressData: Omit<LessonProgress, 'id'> = {
              lessonId,
              completed: false, // Mark as false unless explicitly completing
              score: existingProgress?.score || 0,
              timeSpent: (existingProgress?.timeSpent || 0) + timeSpent,
              attempts: (existingProgress?.attempts || 0) + 1,
              userId: userId,
            };

            if (existingProgress?.id) {
              await setDoc(doc(progressRef, existingProgress.id), newProgressData, { merge: true });
            } else {
              await addDoc(progressRef, newProgressData);
            }
          };

          const getOverallProgress = () => {
            const totalLessons = lessons.length;
            const completedLessons = progress.filter(p => p.completed).length;
            const averageScore = progress.length > 0
              ? progress.reduce((sum, p) => sum + p.score, 0) / progress.length
              : 0;

            return {
              totalLessons,
              completedLessons,
              completionPercentage: (completedLessons / totalLessons) * 100,
              averageScore,
            };
          };

          const isLessonUnlocked = (lessonIdToCheck: number): boolean => {
            // Check if lesson is explicitly completed or if it's the current lesson or earlier
            if (lessonIdToCheck <= currentLesson) return true;
            return false;
          };

          const getCompletedLessonsCount = (): number => {
            return progress.filter(p => p.completed).length;
          };

          return {
            progress,
            currentLesson,
            getLessonProgress,
            completeLesson,
            updateLessonAttempt,
            getOverallProgress,
            isLessonUnlocked,
            getCompletedLessonsCount,
            isStoreReady,
            userId,
          };
        }
        ```

2.  **Modify `client/src/hooks/use-game-store.ts`:**
    * **File:** `client/src/hooks/use-game-store.ts`
    * **Action:** Update to use Firestore listeners and operations for all game data (`ranchData`, `characters`, `buildings`, `rewardNfts`).
    * **Implementation:**
        ```typescript
        // client/src/hooks/use-game-store.ts - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        import { useState, useEffect } from 'react';
        import { getFirestore, collection, query, where, onSnapshot, doc, setDoc, addDoc, updateDoc, getDoc } from 'firebase/firestore';
        import { getAuth } from 'firebase/auth';
        import { appId } from '../firebase-init'; // Import appId from centralized init

        export interface Character {
          id?: string; // Firestore uses string IDs
          name: string;
          type: 'cowboy' | 'outlaw' | 'sheriff' | 'mystic';
          rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';
          level: number;
          experience: number;
          traits: {
            combat: number;
            wisdom: number;
            speed: number;
          };
          imageUrl?: string;
        }

        export interface Building {
          id?: string; // Firestore uses string IDs
          type: 'house' | 'barn' | 'saloon' | 'watchtower' | 'blacksmith';
          level: number;
          position: { x: number; y: number };
        }

        export interface RanchData {
          ranchName: string;
          level: number;
          ranchCoinBalance: number;
          buildingCount: number;
          characterCount: number;
          experience: number;
        }

        export interface RewardNftData {
          id?: string; // Firestore uses string IDs
          lessonId: number;
          nftImageUrl: string;
          rewardName: string;
          awardedAt: Date;
          userId: string; // Add userId for linking
        }

        export function useGameStore() {
          const [ranchData, setRanchData] = useState<RanchData>({
            ranchName: 'Shadow Ranch', level: 1, ranchCoinBalance: 500,
            buildingCount: 0, characterCount: 0, experience: 0,
          });
          const [characters, setCharacters] = useState<Character[]>([]);
          const [buildings, setBuildings] = useState<Building[]>([]);
          const [rewardNfts, setRewardNfts] = useState<RewardNftData[]>([]);
          const [userId, setUserId] = useState<string | null>(null);
          const [isStoreReady, setIsStoreReady] = useState(false);

          // Transient visual states
          const [showChallengeReward, setShowChallengeReward] = useState(false);
          const [currentRewardNftUrl, setCurrentRewardNftUrl] = useState<string | null>(null);
          const [networkPingActive, setNetworkPingActive] = useState(false);
          const [sparkleActive, setSparkleActive] = useState(false);
          const [coinFallActive, setCoinFallActive] = useState(false);
          const [lastStoredMessage, setLastStoredMessage] = useState<string | null>(null);
          const [transactionActive, setTransactionActive] = useState(false);
          const [dataStreamActive, setDataStreamActive] = useState(false);


          useEffect(() => {
            const auth = getAuth();
            const firestoreDb = getFirestore();

            const unsubscribeAuth = onAuthStateChanged(auth, async (user) => {
              const currentUid = user?.uid;
              if (!currentUid) {
                console.warn("No authenticated user UID available in useGameStore. Data might not persist.");
                setIsStoreReady(false);
                return;
              }
              setUserId(currentUid);

              if (firestoreDb && currentUid) {
                // Listener for RanchData (single document per user)
                const userRanchDocRef = doc(firestoreDb, `artifacts/${appId}/users/${currentUid}/ranch/data`);
                const unsubscribeRanch = onSnapshot(userRanchDocRef, (docSnap) => {
                  if (docSnap.exists()) {
                    setRanchData(docSnap.data() as RanchData);
                  } else {
                    // Create default ranch if it doesn't exist
                    const defaultRanch: RanchData = {
                      ranchName: 'Shadow Ranch', level: 1, ranchCoinBalance: 500,
                      buildingCount: 0, characterCount: 0, experience: 0,
                    };
                    setDoc(userRanchDocRef, defaultRanch); // Set initial data
                    setRanchData(defaultRanch);
                  }
                });

                // Listeners for sub-collections
                const unsubscribeCharacters = onSnapshot(collection(firestoreDb, `artifacts/${appId}/users/${currentUid}/characters`), (snapshot) => {
                  setCharacters(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() as Omit<Character, 'id'> })) as Character[]);
                });
                const unsubscribeBuildings = onSnapshot(collection(firestoreDb, `artifacts/${appId}/users/${currentUid}/buildings`), (snapshot) => {
                  setBuildings(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() as Omit<Building, 'id'> })) as Building[]);
                });
                const unsubscribeRewardNfts = onSnapshot(collection(firestoreDb, `artifacts/${appId}/users/${currentUid}/rewardNfts`), (snapshot) => {
                  setRewardNfts(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() as Omit<RewardNftData, 'id'>, awardedAt: doc.data().awardedAt?.toDate() })) as RewardNftData[]);
                });

                setIsStoreReady(true);

                // Cleanup listeners
                return () => {
                  unsubscribeRanch();
                  unsubscribeCharacters();
                  unsubscribeBuildings();
                  unsubscribeRewardNfts();
                };
              }
            });

            // Cleanup auth listener
            return () => unsubscribeAuth();
          }, []);


          // --- CRUD Operations (Firestore Implementation) ---
          const updateRanchData = async (updates: Partial<RanchData>) => {
            if (!userId || !db) return;
            const ranchDocRef = doc(db, `artifacts/${appId}/users/${userId}/ranch/data`);
            await updateDoc(ranchDocRef, updates);
          };

          const addCharacter = async (character: Omit<Character, 'id'>) => {
            if (!userId || !db) return;
            await addDoc(collection(db, `artifacts/${appId}/users/${userId}/characters`), character);
            // CharacterCount is auto-updated by listener, no need to updateRanchData explicitly here if listener is fast enough
          };

          const addBuilding = async (building: Omit<Building, 'id'>) => {
            if (!userId || !db) return;
            await addDoc(collection(db, `artifacts/${appId}/users/${userId}/buildings`), building);
            // BuildingCount is auto-updated by listener
          };

          const spendRanchCoin = async (amount: number) => {
            await updateRanchData({ ranchCoinBalance: Math.max(0, ranchData.ranchCoinBalance - amount) });
          };

          const earnRanchCoin = async (amount: number) => {
            await updateRanchData({ ranchCoinBalance: ranchData.ranchCoinBalance + amount });
          };

          const addExperience = async (amount: number) => {
            const newExp = ranchData.experience + amount;
            const newLevel = Math.floor(newExp / 500) + 1;
            await updateRanchData({ experience: newExp, level: Math.max(ranchData.level, newLevel) });
          };

          const addRewardNft = async (reward: Omit<RewardNftData, 'id' | 'awardedAt'>) => {
            if (!userId || !db) return;
            await addDoc(collection(db, `artifacts/${appId}/users/${userId}/rewardNfts`), { ...reward, awardedAt: new Date() });
          };

          // --- Transient Visual Effect Triggers ---
          const triggerChallengeReward = (nftUrl: string) => {
            setCurrentRewardNftUrl(nftUrl);
            setShowChallengeReward(true);
            // ChallengeReward component handles its own hide timeout
          };

          const triggerNetworkPingAnimation = () => {
            setNetworkPingActive(true);
            setTimeout(() => { setNetworkPingActive(false); }, 3000);
          };

          const triggerSparkleAnimation = () => {
            setSparkleActive(true);
            setTimeout(() => { setSparkleActive(false); }, 2000);
          };

          const triggerCoinFallAnimation = () => {
            setCoinFallActive(true);
            setTimeout(() => { setCoinFallActive(false); }, 2500);
          };

          const triggerTransactionAnimation = () => {
            setTransactionActive(true);
            setTimeout(() => { setTransactionActive(false); }, 3000);
          };

          const triggerDataStreamAnimation = () => {
            setDataStreamActive(true);
            setTimeout(() => { setDataStreamActive(false); }, 3500);
          };

          return {
            ranchData, characters, buildings, rewardNfts,
            addCharacter, addBuilding, spendRanchCoin, earnRanchCoin, addExperience, addRewardNft,
            showChallengeReward, currentRewardNftUrl, triggerChallengeReward,
            networkPingActive, triggerNetworkPingAnimation,
            sparkleActive, triggerSparkleAnimation,
            coinFallActive, triggerCoinFallAnimation,
            lastStoredMessage, setLastStoredMessage,
            transactionActive, triggerTransactionAnimation,
            dataStreamActive, triggerDataStreamAnimation,
            userId,
            isStoreReady,
          };
        }
        ```

3.  **Modify `client/src/App.tsx` for Firebase/Reward Component:**
    * **File:** `client/src/App.tsx`
    * **Action:** Import `ChallengeReward` and link `useGameStore` states to it.
    * **Implementation:**
        ```typescript
        // client/src/App.tsx - DEFINITIVE CONTENT (COPY THIS ENTIRE BLOCK)
        import { Switch, Route } from "wouter";
        import { queryClient } from "./lib/queryClient";
        import { QueryClientProvider } from "@tanstack/react-query";
        import { Toaster } from "@/components/ui/toaster";
        import { TooltipProvider } from "@/components/ui/tooltip";
        import { MainLayout } from "@/components/layout/MainLayout";
        import { HomePage } from "@/pages/HomePage";
        import { LessonsPage } from "@/pages/LessonsPage";
        import { LessonDetailPage } from "@/pages/LessonDetailPage";
        import { RanchPage } from "@/pages/RanchPage";
        import { PlaygroundPage } from "@/pages/PlaygroundPage";
        import NotFound from "@/pages/not-found";
        import { ChallengeReward } from "@/components/game/ChallengeReward"; // NEW Import
        import { useGameStore } from "@/hooks/use-game-store"; // NEW Import for reward

        // Import the centralized Firebase init. No need for global vars here anymore
        import './firebase-init';

        function Router() {
          return (
            <Switch>
              <Route path="/" component={HomePage} />
              <Route path="/lessons" component={LessonsPage} />
              <Route path="/lessons/:id">
                {(params) => <LessonDetailPage lessonId={parseInt(params.id)} />}
              </Route>
              <Route path="/ranch" component={RanchPage} />
              <Route path="/playground" component={PlaygroundPage} />
              <Route component={NotFound} />
            </Switch>
          );
        }

        function App() {
          const { showChallengeReward, currentRewardNftUrl } = useGameStore(); // Get reward states

          return (
            <QueryClientProvider client={queryClient}>
              <TooltipProvider>
                {/* WalletProvider is now handled internally by MainLayout for Firebase auth */}
                <MainLayout>
                  <Toaster />
                  <Router />
                  {/* Render ChallengeReward component globally */}
                  <ChallengeReward
                    isVisible={showChallengeReward}
                    nftImageUrl={currentRewardNftUrl}
                  />
                </MainLayout>
              </TooltipProvider>
            </QueryClientProvider>
          );
        }

        export default App;
        ```

**Phase 3: Update `server/routes.ts` for Lesson 2, Step 3 Verification:**

* **File:** `server/routes.ts`
* **Action:** Ensure the backend verification logic for Lesson 2, Step 3 is correctly in place and matches the expected patterns.
* **Implementation:** (This code block was already provided in `brb_definitive_progression_fix_v3` and should be ensured to be present in `server/routes.ts` exactly as provided there. This includes the logic for L1S1, L2S1, L2S2, and L2S3).

**Phase 4: Finalize Layout Overlap & Positioning Fixes**

* **Objective:** Ensure all UI elements are correctly spaced and positioned, preventing overlaps.

1.  **Refine `LessonLayout.tsx` Header & Main Content Flow (CRITICAL FIX):**
    * **File:** `client/src/components/lessons/LessonLayout.tsx`
    * **Action:** Ensure the fixed header pushes content down correctly and the layout is a proper flex column.
    * **Implementation:**
        * On the outermost `div` of `LessonLayout` (which currently has `min-h-screen bg-gradient-to-br ...`), **ensure** it has the Tailwind classes `flex flex-col`.
        * The `div` containing the `Progress Header` (`border-b border-border/20 ... sticky top-0 z-40`) **must** be changed from `sticky top-0 z-40` to `fixed top-0 left-0 right-0 z-40 w-full`. This will make it consistently fixed at the top and prevent content from scrolling under it.
        * Determine the actual height of this fixed header. Inspect the element in the browser's developer tools. Let's assume its height is `120px` (including padding/margins).
        * Apply `padding-top` to the `<main>` element to push its content below the fixed header:
            ```html
            <main className="flex-grow pt-[120px] pb-[80px]"> {/* Add padding-bottom for fixed bottom nav */}
              {children}
            </main>
            ```
            * *Note:* The `pb-[80px]` is for the fixed bottom navigation bar we're about to add.

2.  **Relocate Navigation Buttons to Bottom in `LessonLayout.tsx` (CRITICAL FIX):**
    * **File:** `client/src/components/lessons/LessonLayout.tsx`
    * **Action:** Move the "Previous" and "Next" buttons from the top header to a new fixed navigation bar at the bottom of the lesson content.
    * **Implementation:**
        * **Remove** the `div` containing the "Previous" and "Next" buttons from the `Progress Header` section at the top.
        * Create a **new `div`** at the very bottom of the `LessonLayout.tsx` component, just before its closing `</div>` tag. This `div` will serve as the bottom navigation bar.
        * Give this new `div` the following classes:
            ```html
            {/* NEW: Fixed Bottom Navigation Bar (COPY THIS ENTIRE BLOCK) */}
            <div className="fixed bottom-0 left-0 right-0 z-40 w-full
                            flex items-center justify-between px-4 py-4
                            bg-background/80 backdrop-blur-sm
                            border-t border-border/20">
              {/* Previous Button */}
              <Button
                onClick={onPrevious}
                disabled={!hasPrevious}
                variant="outline"
                size="sm"
                className="text-xs"
              >
                <ChevronLeft className="w-4 h-4 mr-1" />
                Previous
              </Button>
              {/* Next Button */}
              <Button
                onClick={onNext}
                disabled={nextButtonDisabled} {/* Use the disabled state calculated in LDP */}
                variant="default"
                size="sm"
                className="tech-button tech-button-primary text-xs"
              >
                {nextButtonText || 'Next'} {/* Use the new prop */}
                <ChevronRight className="w-4 h-4 ml-1" />
              </Button>
            </div>
            ```
        * Ensure `TechButton` and `Button` imports are correct.

3.  **Verify `MainLayout.tsx` Footer Positioning (CRITICAL FIX):**
    * **File:** `client/src/components/layout/MainLayout.tsx`
    * **Action:** Confirm the "sticky footer" pattern is correctly implemented.
    * **Implementation:**
        * Ensure the outermost `div` (`min-h-screen bg-gradient-to-br ...`) **definitively** has the Tailwind classes `flex flex-col`.
        * Ensure the `<main>` element (`relative z-10`) **definitively** has `flex-grow`.
        * The footer should now automatically be pushed to the bottom. Review the `mt-` (margin-top) class on the `<footer>` element. If it's `mt-20`, try reducing it to `mt-10` or `mt-8` for a more compact appearance.

**Phase 5: Console Output & Error Message Refinements (Final Polish)**

* **Objective:** Make console output clearer and more distinct for different message types.

1.  **Dynamic Text Coloring for Console Output:**
    * **Files:** `client/src/pages/PlaygroundPage.tsx`, `client/src/pages/LessonDetailPage.tsx`
    * **Action:** Ensure `consoleOutputColor` state is correctly set and applied to the console output div.
    * **Implementation:**
        * In both files, define `const [consoleOutputColor, setConsoleOutputColor] = useState('text-gray-500');`
        * In `handleRun` (Playground) and `handleValidate` (Lesson Detail), when `setConsoleOutput` is called, simultaneously call `setConsoleOutputColor` with the appropriate Tailwind class:
            * `setConsoleOutputColor('text-green-400')` for `challenge_success: true`.
            * `setConsoleOutputColor('text-yellow-400')` for warnings (if `CodeValidator` returns warnings but no errors).
            * `setConsoleOutputColor('text-red-400')` for `challenge_success: false` or backend `success: false` (errors).
        * Apply this `consoleOutputColor` class to the actual console `div` (e.g., `<div className={cn("bg-black/50 rounded-lg p-4 font-mono text-sm min-h-32", consoleOutputColor)}>`).

2.  **Enhanced Backend Error Message Handling:**
    * **File:** `server/routes.ts`
    * **Action:** For general compilation failures, ensure `result.errors` is a structured array that the frontend can parse.
    * **Implementation:**
        * In the final `else` block (the generic compilation failure using `Math.random()`), ensure the `result` structure includes an `errors` array, and make the error messages more specific.
            ```typescript
            // In server/routes.ts, the final generic `else` block for compilation failure:
            else { // This is the fallback if no challenge matched
              // Simulate compilation process with random success/failure
              await new Promise(resolve => setTimeout(resolve, 1500)); // Adjusted simulation time

              const success = Math.random() > 0.1; // 90% success rate

              if (success) {
                res.json({
                  success: true,
                  challenge_id: "generic_compile_success",
                  challenge_success: true,
                  result: {
                    compiled: true,
                    programId: `Program${Date.now()}`,
                    deploymentAddress: `Deploy${Date.now()}`,
                    logs: [
                      "✅ Code compiled successfully.",
                      "🚀 Program deployed to devnet (simulated).",
                      "💰 Transaction confirmed (simulated).",
                      "🎉 Program executed with no errors!"
                    ],
                    console_output: "Compilation & Deployment Successful! Check logs for details."
                  }
                });
              } else {
                res.json({
                  success: false,
                  challenge_id: "generic_compile_failure",
                  challenge_success: false,
                  error: "Compilation failed: Review your code for syntax and logic errors.",
                  result: {
                    compiled: false,
                    errors: [ // Provide more detailed mock errors
                      "Line 15: Syntax Error: Missing semicolon after statement.",
                      "Line 23: Semantic Error: Variable 'ranch_account' is undefined in this scope.",
                      "Line 30: Anchor Constraint Error: Invalid account constraint or missing signer for 'owner' account.",
                      "Ensure your program ID is correctly declared."
                    ]
                  }
                });
              }
            }
            ```
        * **Frontend Display of Structured Errors:**
            * **Files:** `client/src/pages/PlaygroundPage.tsx`, `client/src/pages/LessonDetailPage.tsx`
            * **Action:** Update the rendering of the console output to properly display `result.errors` if they exist.
            * **Implementation:**
                * Inside `handleRun`/`handleValidate`, when `data.success === false && data.result.errors`, modify `setConsoleOutput`.
                * Instead of just `data.error`, render `data.error + '\n' + (data.result.errors || []).join('\n')`. This relies on `whitespace-pre-wrap` for rendering.

By executing these critical fixes, the application's user flow will be smooth and intuitive, the layout will be stable, and all feedback messages will be clear and helpful for the user's learning journey.
